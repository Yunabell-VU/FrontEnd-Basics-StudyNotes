# ECMAScript 6 -- ES6

ECMAScript 是语言的标准，规定了语法，如基本数据类型（数字、字符串、布尔值，undefined、null），引用数据类型（对象），和API（方法、函数）



[TOC]



## let和const

1. let 和 const 是什么

​    声明变量或声明常量

​    var 声明变量

​    **let** 代替 var，声明**变量**

​    **const** 声明**常量** constant



2. let 和 const 的用法

​    var 一样

```javascript
var username = 'Alex';
let age = 18;
const sex = 'male';
console.log(username, age, sex);
```



3. 什么是变量，什么是常量

```javascript
username = 'ZS';
age = 28;
console.log(username, age);

// 报错
sex = 'female';
```

 var、let声明的就是变量，变量一旦初始化之后，还可以重新赋值

 const 声明的就是常量，常量一旦初始化，就不能重新赋值了，否则就会报错



### const

1. 为什么需要 const

```javascript
let sex = 'male';
 //  ...
 sex = 'female';
 console.log(sex);

const sex = 'male';
// ...
sex = 'female'; //报错
console.log(sex); 
```

const 就是为了那些一旦初始化就不希望重新赋值的情况设计的



2. const 的注意事项

   2.1.使用 const 声明常量，一旦声明，就必须立即初始化，不能留到以后赋值

   ```javascript
   const sex;
   sex='male' //报错
   
   //应该这样初始化
   const sex = 'male';
   ```

   

   2.2.const 声明的常量，允许在不重新赋值的情况下修改它的值

   基本数据类型（不可以重新赋值）

   ```JavaScript
   //报错
   const sex = 'male';
   sex = 'female';
   ```

   引用数据类型

   ```JavaScript
   const person = { username: 'Alex' };
   person = {};//报错
   person.username = 'ZhangSan';//不报错
   console.log(person);//person被修改
   ```

   

3. 什么时候用 const，什么时候用 let

   ```JavaScript
   // for循环这种需要改变的用let
   for (let i = 0; i < 3; i++) {}
   
   //不知道用什么时，先用const，如后面需要修改再改回let
   const username = 'Alex';
   // ...
   username = 'ZhangSan';
   ```

   

### let, const 和 var 的区别

1. 重复声明

   已经存在的变量或常量，又声明了一遍

   var 允许重复声明，let、const 不允许

```javascript
var a = 1;
// ...
var a = 2;//不报错

let a = 1;
// ...
let a = 2;//报错
console.log(a);
```



```javascript
function func(a) {
 let a = 1; //报错。 函数参数形式存在的变量也不可以被再次声明
}

func();
```



2. 变量提升

  var 会提升变量的声明到当前作用域的顶部

```javascript
console.log(a); //报错
```

   

```javascript
console.log(a); //不报错，会打印 undefined
var a = 1;
```

  相当于

```javascript
var a;
console.log(a);
a = 1;
console.log(a);
```



**let、const 不存在变量提升**

```javascript
console.log(a); //报错
let a = 1;
```

养成良好的编程习惯，对于所有的变量或常量，做到先声明，后使用



3. 暂时性死区

只要作用域内存在 let、const，它们所声明的变量或常量就**自动“绑定”这个区域**，不再受到外部作用域的影响

let、const 存在暂时性死区

```javascript
let a = 2;
let b = 1;

//注意，函数只有在被调用时才会形成函数作用域，只是声明并不会存在作用域
function func() {
  console.log(b);//不报错，打印出 1
  console.log(a);//报错，并不会打印外部的 a, 因为下面有let已经绑定了a
  let a = 1;
}
func();
```

 养成良好的编程习惯，对于所有的变量或常量，做到先声明，后使用



4. window 对象的属性和方法

全局作用域中，var 声明的变量，通过 function 声明的函数，会自动变成 window 对象的属性或方法

let、const 不会

```javascript
// var/function
var age = 18;

function add() {}
console.log(window.age); //18
console.log(window.add === add); //true

// let/const
let age = 18;
const add = function () {};
console.log(window.age); //undefined
console.log(window.add === add); //false
```

   

### 块级作用域

1. 什么是块级作用域

 var 没有块级作用域

```javascript
for (var i = 0; i < 3; i++) {
  console.log(i);
}
console.log(i); //3
```



let/const 有块级作用域

```javascript
for (let i = 0; i < 3; i++) {
   console.log(i);
}
console.log(i); // 报错， i is not defined
```

 

2. 作用域链

```javascript
function func() {
   for (let i = 0; i < 3; i++) {
   console.log(i);
   }
}
func();//函数调用时形成函数作用域，函数调用结束，作用域销毁
console.log(i);
```

<img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/image-20210627181210676.png" alt="image-20210627180317315" style="zoom:80%;" /> 

作用域链：内层作用域->外层作用域->...->全局作用域



3. 有哪些块级作用域

```javascript
 // {}
{
  let age = 18;
  console.log(age);
}
console.log(age); //报错

```

  

```javascript
for(){}
while(){}
do{}while()
if(){}
switch(){}
```



```javascript
function(){}

const person = { //对象的{}不构成作用域
  getAge: function () {} //对象内的方法构成函数作用域
};
```



### let和const的应用



<img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/image-20210628152931953.png" alt="image-20210627181210676" style="zoom:50%;" />

三个按钮，点击按钮打印对应数值

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>let 和 const 的应用</title>
    <style>
      body {
        padding: 50px 0 0 150px;
      }

      .btn {
        width: 100px;
        height: 100px;
        margin-right: 20px;
        font-size: 80px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <button class="btn">0</button>
    <button class="btn">1</button>
    <button class="btn">2</button>

    <script>
      //....
    </script>
  </body>
</html>

```

1. 使用 var 来实现

```JavaScript
// var
var btns = document.querySelectorAll('.btn');
for (var i = 0; i < btns.length; i++) {
  btns[i].addEventListener(
      'click',
      function () {
        console.log(i); //点击任何按钮只会打印出 3
      },
   false //是否捕获
   );
}
```



2. 闭包方式解决上面var的问题

```javascript
var btns = document.querySelectorAll('.btn');
for (var i = 0; i < btns.length; i++) {
  //采用立即执行匿名函数的方式
  (function (index) {
     btns[index].addEventListener(
       'click',
       function () {
         console.log(index); //可以打印出对应的按钮数值
       },
       false
     );
   })(i);
}
```



3. let和const实现

```javascript
 // 3.let/const
let btns = document.querySelectorAll('.btn');
for (let i = 0; i < btns.length; i++) {
   btns[i].addEventListener(
      'click',
      function () {
         console.log(i);
      },
      false
   );
}
```

------



## 模板字符串

1. 认识模板字符串

```javascript
//单引号或双引号引入的是一般字符串
const username1 = 'alex';
"alex"

//模板字符串用反引号来引入
const username2 = `alex`;
console.log(username1, username2, username1 === username2); //alex alex true
```



2. 模板字符串与一般字符串的区别

```javascript
const person = {
  username: 'Alex',
  age: 18,
  sex: 'male'
};
```



```javascript
//一般字符串使用加号来拼接
const info =
 '我的名字是：' + person.username +
  ', 性别：' + person.sex +
  ', 今年' + person.age +
  '岁了';

console.log(info);

//模板字符串可以在字符串内直接引用变量
const info = `我的名字是：${person.username}, 性别：${person.sex}, 今年${person.age}岁了`;
console.log(info);
```

和其他东西一起使用的时候，使用模板字符串，方便注入

其他情况下使用模板字符串或一般字符串都行



### 模板字符串注意事项

1. 输出多行字符串

   一般字符串

```JavaScript
const info = '第1行\n第2行';
console.log(info); //实现换行
```

  模板字符串

```javascript
const info = `第1行\n第2行`; //换行
const info = `第1行
第2行`; //也可换行，但是前面如果有缩进空格，也会被保留
console.log(info);
```

模板字符串中，所有的空格、换行或缩进都会被保留在输出之中



2. 输出 ` 和 \ 等特殊字符

```javascript
const info = `'\`\\`;//转义字符 \ , 要输出 \， 也使用 \， 即 \\
console.log(info);
```



3. 模板字符串的注入

```javascript
//${}中可以放入 哪些内容？

const username = 'alex';
const person = { age: 18, sex: 'male' };
const getSex = function (sex) {
  return sex === 'male' ? '男' : '女';
};

const info = `${username}, ${person.age + 2}, ${getSex(person.sex)}`;
console.log(info);
```

只要最终可以得出一个值的就可以通过 ${} 注入到模板字符串中



### 模板字符串的应用

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>模板字符串的应用</title>
    <style>
      body {
        padding: 50px 0 0 300px;
        font-size: 22px;
      }

      ul {
        padding: 0;
      }

      p {
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <p>学生信息表</p>
    <ul id="list">
      <li style="list-style: none;">信息加载中……</li>
    </ul>

    <script>
      // 数据
      const students = [
        {
          username: 'Alex',
          age: 18,
          sex: 'male'
        },
        {
          username: 'ZhangSan',
          age: 28,
          sex: 'male'
        },
        {
          username: 'LiSi',
          age: 20,
          sex: 'female'
        }
      ];

      const list = document.getElementById('list');

      let html = '';

      for (let i = 0; i < students.length; i++) {
        html += `<li>我的名字是：${students[i].username},${students[i].sex},${students[i].age}</li>`;
      }

      // console.log(html);
      list.innerHTML = html;
    </script>
  </body>
</html>

```



------

## 箭头函数

1. 认识箭头函数

```javascript
// (参数) => {函数体}
const add = (x, y) => {
  return x + y;
};
console.log(add(1, 1)); // 2
```



2. 箭头函数的结构

  const/let 函数名 = 参数 => 函数体



3. 如何将一般函数改写成箭头函数

```javascript
// 声明形式
function add() {}

// 声明形式->函数表达式形式
const add = function () {};

// 函数表达式形式->箭头函数
const add = () => {};
```



### 箭头函数的注意事项



箭头函数可以化简，前提是单个参数, 单行函数体, 单行对象

1. 单个参数

 单个参数可以省略圆括号

```javascript
const add = x => {
  return x + 1;
};

console.log(add(1));
```

   无参数或多个参数不能省略圆括号

```javascript
const add = () => {
  return 1 + 1;
};

const add = (x, y) => {
  return x + y;
};

console.log(add(1, 1));
```



2. 单行函数体

   单行函数体可以同时省略 {} 和 return

```javascript
const add = (x, y) => {
  return x + y;
};

const add = (x, y) => x + y;
console.log(add(1, 1));
```

   多行函数体不能再化简了

```javascript
const add = (x, y) => {
  const sum = x + y;
  return sum;
};
```



3. 单行对象

```JavaScript
const add = (x, y) => {
  return {
    value: x + y
  };
};

const add = (x, y) => ({
  value: x + y
});
```

 如果箭头函数返回单行对象，可以在 {} 外面加上 ()，让浏览器不再认为那是函数体的花括号

```javascript
//单行数组
const add = (x, y) => [x, y];
console.log(add(1, 1)); // [1,1]
```



### 非箭头函数中的this 指向

1.全局作用域中的 this 指向

```JavaScript
console.log(this); // window
```



2. 一般函数（非箭头函数）中的 this 指向

```javascript
'use strict';

//只有在函数调用的时候 this 指向才确定，不调用的时候，不知道指向谁
//this 指向和函数在哪儿调用没关系，只和谁在调用有关

function add() {
	console.log(this);
}

// 没有具体调用对象的话，this 指向 undefined，在非严格模式下，转向 window
// 严格模式就指向 undefined
add(); // undefined->window（非严格模式下）
window.add();//此处严格模式也是指向 window

const calc = {
	add: add //前面是对象里属性名，后面是方法名
};

calc.add(); // calc

const adder = calc.add;//此时并没有调用
adder(); // undefined (严格)-> window（非严格模式下）

document.onclick = function () {
	console.log(this); //document
};
//点击document时，相当于执行了这个方法 document.onclick();

function Person(username) {
	this.username = username;
	console.log(this); //Person
}

const p = new Person('Alex');
```



### 箭头函数中的this指向

1. 箭头函数中的 this 指向

  箭头函数没有自己的 this

```JavaScript
const calc = {
	add: () => {
		console.log(this);
	}
};

calc.add(); // window， 箭头函数中找不到this，对象没有作用域，所以找到了全局作用域
```



2. 练习

```JavaScript
'use strict';
const calc = {
	add: function () {
	// this
		const adder = () => {
			console.log(this);
		};
	adder();
	}
};

calc.add(); // calc {add: f}

const addFn = calc.add; //赋值，没有调用。 addFn没有具体调用对象
addFn(); // undefined->window
```



### 不适用箭头函数的场景

1. 作为构造函数

因为箭头函数没有this

```JavaScript
const Person = () => {}; //不可以这样使用
new Person(); //报错，不是构造函数
```



2. 需要 this 指向调用对象的时候

```JavaScript
//如下面的例子需要用到this
document.onclick = function () {
	console.log(this); //this指向document
};

//此时this指的就不是document而是window
document.addEventListener(
	'click',
	() => {
		console.log(this); //window
	},false
);
```



3. 需要使用 arguments 的时候

   箭头函数中没有 arguments

```JavaScript
function add() {
	console.log(arguments);
}

add(1,2,3,4,5); //Arguments(5)[1,2,3,4,5,...]

const add = () => console.log(arguments);
add(); //报错，arguments is not defined

// 剩余参数可解决此类问题，但一般使用arguments最好还是不要使用箭头函数
```



### 箭头函数的应用

<img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/image-20210627180317315.png" alt="image-20210628152931953" style="zoom:80%;" />

点击开始按钮，开始计时

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>箭头函数的应用</title>
    <style>
      body {
        padding: 50px 0 0 250px;
        font-size: 30px;
      }

      #btn {
        width: 100px;
        height: 100px;
        margin-right: 20px;
        font-size: 30px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <button id="btn">开始</button>
    <span id="result">0</span>

    <script>
      // ...
    </script>
  </body>
</html>

```



不使用箭头函数

```JavaScript
const btn = document.getElementById('btn');
const result = document.getElementById('result');
const timer = {
	time: 0,
	start: function () {
		// this指向timer
		var that = this;
		// var self = this; 或者用self
		btn.addEventListener(
			'click', 
            function () {
                //这个函数的this指向 btn
				setInterval(function () {
					console.log(this); //指向window
					//this.time++; //这里用this会报错
					//result.innerHTML = this.time;
					that.time++;
					result.innerHTML = that.time;
				}, 1000);
			},false //冒泡
		);
    }
};

timer.start();
```



使用箭头函数

```JavaScript
const btn = document.getElementById('btn');
const result = document.getElementById('result');

const timer = {
	time: 0,
	start: function () {
		// console.log最终找到这层的 this
		btn.addEventListener(
			'click',
			() => {
			// console.log中的this指向这层，但这层也没有自己的this，所以继续往上
			setInterval(() => {
				console.log(this);
				this.time++;
				result.innerHTML = this.time;
			}, 1000);
		},false
		);
	}
};

timer.start();
```



------

## 解构赋值

### 数组的解构赋值

1. 认识解构赋值

```JavaScript
const arr = [1, 2, 3];

const a = arr[0];
const b = arr[1];
const c = arr[2];

console.log(a, b, c);

const [a, b, c] = [1, 2, 3]; //直接给a b c单独赋值，但abc还是在数组中
console.log(a, b, c); //1 2 3
```



2. 什么是解构赋值

解析某一数据的结构，将我们想要的东西提取出来，赋值给变量或常量



#### 数组解构赋值的原理

1. 模式（结构）匹配

```JavaScript
[] = [1, 2, 3];

```



2. 索引值相同的完成赋值

```javascript
const [a, b, c] = [1, 2, 3];
console.log(a, b, c); //1 2 3

// 不取的，可以直接用逗号跳过
const [a, [, , b], c] = [1, [2, 4, 5], 3];
console.log(a, b, c); // 1 5 3
```



#### 数组解构赋值的默认值

1. 默认值的基本用法

```JavaScript
const [a, b] = [];
console.log(a, b);// undefined undefined
//相当于
const [a, b] = [undefined, undefined];

//设置默认值，如果没有取到赋值，会按默认值来赋值
const [a = 1, b = 2] = [];
console.log(a, b); //1 2
```



2. 默认值的生效条件

```JavaScript
// 只有当一个数组成员严格等于（===）undefined 时，对应的默认值才会生效

const [a = 1, b = 2] = [3, 0];
console.log(a, b);//3 0

const [a = 1, b = 2] = [3, null];
console.log(a, b); //3 null

const [a = 1, b = 2] = [3];
console.log(a, b); //3 2
```



3. 默认值表达式


```JavaScript
// 如果默认值是表达式，默认值表达式是惰性求值的

const func = () => {
	console.log('我被执行了');
	return 2;
};

const [x = func()] = [1];
console.log(x); //1   不输出'我被执行了'

const [x = func()] = [];
console.log(x);//我被执行了 2
```



#### 数组解构赋值的应用

1. 常见的类数组的解构赋值

```JavaScript
// arguments

function func() {
	console.log(arguments);
	console.log(arguments.push);//undefined 没有push
	const [a, b] = arguments;
	console.log(a, b); //1 2
}
func();//Arguments[]
func(1, 2);//Arguments[1,2] 注意Arguments并不是数组，而是类数组

// NodeList

//html部分写入三个p标签
console.log(document.querySelectorAll('p')); //NodeList(3)[p, p, p] 也是一个类数组

const [p1, p2, p3] = document.querySelectorAll('p');
console.log(p1, p2, p3);//<p>123</p> <p>321</p> <p>456</p>
```



2. 函数参数的解构赋值

```JavaScript
const array = [1, 1];
const add = arr => arr[0] + arr[1];
console.log(add(array));//2

const add = ([x, y]) => x + y;
console.log(add(array));//2
console.log(add([])); //NaN

const add = ([x = 0, y = 0]) => x + y;
console.log(add(array));//2
console.log(add([])); //0

```



3. 交换变量的值

```JavaScript
let x = 1;
let y = 2;

let tmp = x;
x = y;
y = tmp;
console.log(x, y); //2 1

[x, y] = [y, x];//相当于 [x, y] = [2, 1]
console.log(x, y);//2 1
```



### 对象的解构赋值

#### 对象解构赋值的原理

1. 模式（结构）匹配

```JavaScript
//{}={} 左边和右边都要是对象的形式
```



2. 属性名相同的完成赋值

```JavaScript
//左右属性名需相同，顺序不需要一致
const { age, username } = { username: 'Alex', age: 18 };
console.log(age, username);//18 "Alex"

//上面的例子是对象的简写，完整的写法如下
const { age: age, username: username } = { username: 'Alex', age: 18 };
console.log(age, username); //18 "Alex"
```



```JavaScript
// 取别名
const { age: age, username: uname } = { username: 'Alex', age: 18 };
console.log(age, username); //报错，username is not undefined
console.log(age, uname); //18 "Alex"
```



#### 对象解构赋值的注意事项

1. 默认值的生效条件

```JavaScript
// 对象的属性值严格等于 undefined 时，对应的默认值才会生效

const { username = 'ZhangSan', age = 0 } = { username: 'alex' };
console.log(username, age); //alex 0
```



2. 默认值表达式( 和数组类似 )

   如果默认值是表达式，默认值表达式是惰性求值的



3. 将一个已经声明的变量用于解构赋值

```JavaScript
// 如果将一个已经声明的变量用于对象的解构赋值，整个赋值需在圆括号中进行

let { x } = { x: 1 };
console.log(x); //1


let x = 2;
let { x } = { x: 1 }; //报错， Identifier 'x' has already been declared
{ x } = { x: 1 }; //报错，SyntaxError, {}被误认为是块级作用域
({ x } = { x: 1 }); //不报错，成功赋值
[x] = [1]; //不报错，成功赋值
console.log(x); //1
```



4. 可以取到继承的属性

```JavaScript
const { a } = {};
console.log(a); //undefined

//上面的例子赋值不到因为对象是空的，但是toString这类Object属性可以被继承
const { toString } = {};
console.log(toString); //f toString(){}

Object.prototype
console.log(Object.prototype);
console.log({});
```



#### 对象解构赋值的应用

1. 函数参数的解构赋值

```JavaScript
//对象作为参数的箭头函数调用
const logPersonInfo = user => console.log(user.username, user.age);
logPersonInfo({ username: 'alex', age: 18 }); //Console输出 alex 18

//解构赋值的用法
const logPersonInfo = ({age, username}) =>
console.log(username, age);
logPersonInfo({ username: 'alex', age: 18 }); //Console输出 alex 18

const logPersonInfo = ({ age = 0, username = 'ZhangSan' }) =>
console.log(username, age);
logPersonInfo({}); //Console输出 Zhangsan 0
```



2. 复杂的嵌套

```JavaScript
//一般方法
const obj = {
	x: 1,
	y: [2, 3, 4],
	z: {
		a: 5,
		b: 6
	}
};

const { x, y, z } = obj;
console.log(x, y, z);

//解构赋值
const {
	y, //从 y:y 简化
	y: [, yy], //yy取到3
	z,
	z: { b }
} = obj;

console.log(yy, y, z, b);

[, yy] = [2, 3, 4]
```



### 其他数据类型的解构赋值

1. 字符串的解构赋值

```JavaScript
// ''='hello' 错误的使用方法

// 数组形式的解构赋值
const [a, b, , , c] = 'hello';
console.log(a, b, c); //h e o

// 对象形式的解构赋值
const { 0: a, 1: b, length } = 'hello'; //对应字符的index作为解构的属性名
console.log(a, b, length); //h e 5
```

字符串既可以按数组形式来解构赋值，也可以按对象形式来解构赋值



2. 数值和布尔值的解构赋值

```JavaScript
// 先将等号右边的值转为对象
console.log(new Number(123)); //Number {123}

const {a} = 123; 
console.log(a); //undefined

const { a = 1, toString } = 123;
console.log(a, toString); //1 f toString() 可以取到方法，在Number()继承的prototype下

const { b = 2, toString } = true;
console.log(b, toString); //2 f toString()
```



3. undefined 和 null 的解构赋值

```JavaScript
// 由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错
const { toString } = undefined;
const { toString } = null;
```



### 解构赋值的常见应用场景

1. 交换变量的值

```JavaScript
let x = 1;
let y = 2;
[x, y] = [y, x]; // tips：x 和 y 已经声明了，这里就不用再添加 let 等关键字声明了
console.log(x, y) // 2 1
```



2. 从函数返回多个值

   （1） 返回一个数组

   函数返回结果一个数组，对该数组进行解构，获取里面的每个值

```JavaScript
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();
console.log(a, b, c) // 1 2 3
```

​		（2）返回一个对象

​		函数返回结果一个对象，对该对象进行解构，获取里面的每个值

```JavaScript
function example() {
    return {
        foo: 1,
        bar: 2
    };
}
let {
    foo,
    bar
} = example();

console.log(foo, bar) // 1 2
```



3. 函数参数的定义

   可以方便地将一组参数与变量名对应起来

   （1）参数是一组有次徐的值

   ```JavaScript
    function f([x, y, z]) {
       console.log(x, y, z)
   }
   f([1, 2, 3])
   
   //输出1 2 3
   ```

   （2）参数是一组无次序的值

   ```javascript
   function f({
       x,
       y,
       z
   }) {
       console.log(x, y, z)
   }
   f({
       z: 1,
       x: 2,
       y: 3
   })
   //输出 2 3 1
   ```

   

4. 指定函数参数的默认值

   指定参数的默认值，就避免了在函数体内部再去判断传入的参数是否有价值了

```JavaScript
function foo({x, y = 5}) {
    console.log(x, y);
}
foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
```



5. 遍历Map解构

   解构赋值，获取键名和键值非常方便

   ```JavaScript
   var map = new Map();
   map.set('李四', '18');
   map.set('张三', '20');
   for (let [key, value] of map) {
       console.log(`${key}今年${value}岁`);
   }
   ```

   

6. 加载模块

   让引入部分更加明确

   ```JavaScript
   import {x, y} from 'xxx';
   ```

   

7. 提取JSON数据

   快速提取JSON数据

   ```JavaScript
   var jsonData = {
       "name": "小慕",
       "age": "18",
       "data": [1, 2, 3, 4],
       "status": "OK"
   }
   let {
       name,
       age,
       data,
       status
   } = jsonData
   console.log(name, age, data, status);
   ```

   

------

## 对象字面量的增强与函数参数的默认值

### 对象字面量的增强

#### 属性和方法的简洁表示法

1. 对象字面量是什么 （对象声明的两种方法）

   a.实例化构造函数生成对象 （基本不用）

```JavaScript
const person = new Object();
person.age = 18;
person.speak = function () {};
```



   b.对象字面量 （常用）

```JavaScript
const person = {
	age: 18,
	speak: function () {}
};
```

   

2. 属性的简洁表示法

```JavaScript
// 键名和变量或常量名一样的时候，可以只写一个

const age = 18;
const person = {
	// age: age
	age
};

console.log(person); //{age:18}
```



3. 方法的简洁表示法

```JavaScript
// 方法可以省略冒号和 function 关键字

const person = {
	// speak: function () {}
	speak() {}
};

console.log(person);
```



#### 方括号的语法

1. 方括号语法的用法

```javascript
const prop = 'age';
const person = {};

person.prop = 18;
//person并没有age属性，而是prop属性
console.log(person); //{prop:18}

//ES6之前的语法
person[prop] = 18;
console.log(person); //{age:18}

// ES6新增方括号语法可以写在对象字面量中
const person = {
	[prop]: 18
};

console.log(person);//{prop:18}
```



2. 方括号中可以放什么

```JavaScript
//${}
// [值或通过计算可以得到值的（表达式）]

const prop = 'age';

const func = () => 'age2';

const person = {
	// [prop]: 18
	// [func()]: 18
	// ['sex']: 'male'
	
    ['s' + 'ex']: 'male' //字符串的拼接
};

console.log(person);
```



3. 方括号语法和点语法的区别

```JavaScript
// 点语法是方括号语法的特殊形式

const person = {};

// person.age 等价于 person['age']
```



```JavaScript
// 属性名由数字、字母、下划线以及 $ 构成，并且数字还不能打头的时候可以使用点语法

// age18_$ √
// 18age ×

// 合法标识符可以用来作为变量或常量名

// 当你的属性或方法名是合法标识符时，可以使用点语法，其他情况下请使用方括号语法

const obj = {
    "age": 2,
    "8i":"imooc"
}
// age是合法标识符，点语法和方括号语法都可以访问
console.log(obj.age) // 2
console.log(obj['age']) // 2
//8i不属于合法的标识符，使用点语法访问属性会报错
// console.log(obj.8i)  // 报错  为了方便看到其他结果，所以将这句代码注释了，可以自己打开注释测试下代码效果
// 不符合语法标识符的属性，可以使用方括号语法访问
console.log(obj['8i'])// imooc


//使用变量或者常量保存属性名时，只能使用方括号语法，不能使用点语法
const obj = {
    "age": 2,
    "8i": "imooc"
}
// 定义一个常量property，值为age
const property = "age"
// 当属性为变量或常量时，必须通过方括号语法，即：obj[property]，使用property保存的值age，所以等价于obj.age这种写法
console.log(obj[property]) // 2
// 当属性为变量或常量时，如果通过点语法，会将property看做字符串，表示访问obj对象下的property属性，而不是访问obj下的age属性，而obj对象中没有property属性，所以返回结果为undefined
console.log(obj.property) // undefined
```



### 函数参数的默认值

1. 认识函数参数的默认值

```JavaScript
// 调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值

multiply(2, 1);
multiply(2);
```



2. 函数参数默认值的基本用法

```JavaScript
//不用默认值的写法
const multiply = (x, y) => {
	if (typeof y === 'undefined') {
		y = 1;
	}
	return x * y;
};
console.log(multiply(2));// 2

//函数默认值的写法
const multiply = (x, y = 1) => x * y;
console.log(multiply(2));
```



#### 函数参数默认值的注意事项

1. 默认值的生效条件

```JavaScript
// 不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效

const multiply = (x, y = 1) => x * y;

console.log(multiply(2, 0)); // 0
console.log(multiply(2, null)); // 0 null会先转化成0

console.log(multiply(2, undefined)); // 2
console.log(multiply(2)); // 2
```

  

2. 默认值表达式

```JavaScript
 // 如果默认值是表达式，默认值表达式是惰性求值的
```

 

3. 设置默认值的小技巧

```JavaScript
// 函数参数的默认值，最好从参数列表的右边开始设置
   
const multiply = (x = 1, y) => x * y;
console.log(multiply(undefined, 2));

const multiply = (x, y = 1) => x * y;
console.log(multiply(2));
```



#### 函数参数默认值的应用

1. 接收很多参数的时候

```JavaScript
// 实际开发不使用这种方法，否则记不住参数的位置
const logUser = (username = 'ZhangSan', age = 0, sex = 'male') =>
	console.log(username, age, sex);

logUser('Alex', 18, 'male'); // Alex 18 male
logUser(); // ZhangSan 0 male
```

  

2. 接收一个对象作为参数

```JavaScript
const logUser = options =>
	console.log(options.username, options.age, options.sex);

logUser({
	username: 'alex',
	age: 18,
	sex: 'male'
});

//一直使用options. 有点麻烦， 所以可以使用解构赋值

const logUser = ({ username = 'zhangsan', age = 0, sex = 'male' }) =>
	console.log(username, age, sex);

logUser({
	username: 'alex',
	age: 18,
	sex: 'male'
});

logUser({ username: 'alex' });
//相当于
{ username = 'zhangsan', age = 0, sex = 'male' } = { username: 'alex' }


logUser({});

const logUser = ({ username = 'zhangsan', age = 0, sex = 'male' }) =>
	console.log(username, age, sex);
logUser();
//相当于undefined的解构赋值
{ username = 'zhangsan', age = 0, sex = 'male' } = undefined


const logUser = ({ username = 'zhangsan', age = 0, sex = 'male' } = {}) =>
	console.log(username, age, sex);
logUser();
//相当于对象{}的解构赋值
{ username = 'zhangsan', age = 0, sex = 'male' } = {}
```

------



## 剩余参数与展开运算符



### 剩余参数

1.认识剩余参数

```JavaScript
//允许调用可以传入任意个数参数
const add = (x, y, z, ...args) => {}; //args并不是固定名字，可以自定义
```



2.剩余参数的本质

```JavaScript
const add = (x, y, ...args) => {
	console.log(x, y, args); //使用的时候不用加...
};

//剩余参数会被加入命名的数组中

add(); // undefined undefined
add(1); // 1 undefined
add(1, 2); // 1 2
add(1, 2, 3, 4, 5); // 1 2 [3, 4, 5]

// 剩余参数永远是个数组，即使没有值，也是空数组

3, 4, 5->[3, 4, 5]
```



#### 剩余参数的注意事项

1. 箭头函数的剩余参数

```JavaScript
箭头函数的参数部分即使只有一个剩余参数，也不能省略圆括号
const add = (...args) => {};
```



2. 使用剩余参数替代 arguments 获取实际参数

```JavaScript
const add = function () { //箭头函数没有 arguments
	console.log(arguments);
};

const add = (...args) => {
	console.log(args); //剩余函数是纯数组，arguments是类数组，缺少数组自带的一些函数，没有剩余参数好用
};

add(1, 2);
```



3. 剩余参数的位置

```JavaScript
// 剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错

const add = (x, y, ...args) => {
	console.log(args);
};
```



#### 剩余参数的应用

1. 完成 add 函数

```JavaScript
const add = (...args) => {
	let sum = 0;
	for (let i = 0; i < args.length; i++) {
		sum += args[i];
	}
	// reduce
    return sum;
};

console.log(add()); // 0
console.log(add(1, 1)); // 2
console.log(add(1, 2, 3)); // 6
```



2. 与解构赋值结合使用

```JavaScript
// 剩余参数不一定非要作为函数参数使用

const [num, ...args] = [1, 2, 3, 4];
console.log(num, args); //1 [2, 3, 4]

// 必须是最后一个
const [...args,num] = [1, 2, 3, 4];
console.log(num, args); //报错 

//函数剩余参数和解构赋值的结合
const func = ([num, ...args]) => {};
func([1, 2, 3]);

//剩余参数（元素）和对象结构的结合
const { x, y, ...z } = { a: 3, x: 1, y: 2, b: 4 };
console.log(x, y, z); // 1 2 {a: 3, b: 4}

// 必须是最后一个
const { x, ...z, y } = { a: 3, x: 1, y: 2, b: 4 };
console.log(x, y, z); //报错

const func = ({ x, y, ...z }) => {};
func({ a: 3, x: 1, y: 2, b: 4 });
```



#### reduce 的原理

1. 简介

   reduce方法是数组的归并方法，这个方法与迭代方法（forEach方法等）一样，都会对数组进行遍历，不同的是reduce方法的回调函数中的第一个参数得到的是迭代计算后的结果。

2. 语法

   reduce方法接受两个参数，如下：

   ```JavaScript
   arr.reduce(callback(acl,val,idx,array),initVal)
   ```

   第一个参数是要执行的函数，该函数中传入的参数：

   - acl：上一次调用回调函数返回的累积值，必须要有

   - val：当前元素，必选

   - idx：当前索引(Optional)

   - array：被遍历的数组(Optional)

     

   第二个参数是函数迭代的数值：

   - initVal：第一次调用函数时的第一个参数的值,若没有提供初始值,则使用数组中的第一个元素



3. 举例

   （1）没有设置函数的初始迭代值

   ```JavaScript
   //对arr进行元素求和
   
   let arr = [1, 2, 3, 4];
   let sum = arr.reduce(function(acl, val) {
       return acl + val;
   })
   console.log(sum);
   
   //以上过程迭代三次，函数迭代的初始值是1
   //1st： acl = 1; val = 2; idx = 1; array = arr; 函数返回值为： 3
   //2nd： acl = 3; val = 3; idx = 2; array = arr; 函数返回值为： 6
   //3rd： acl = 6; val = 4; idx = 3; array = arr; 函数返回值为： 10
   ```

   （2）设置初始迭代值

   ```JavaScript
   let arr = [1, 2, 3, 4];
   let sum = arr.reduce(function(acl, val, idx, array) {
       console.log(acl, val, idx, array);
       return acl + val;
   }, 10) //初始值为10
   console.log(arr, sum);
   
   // 添加了一个初始的迭代值10， 也就是让acl从10开始计算，结合下图打印结果，可知这里迭代了4次，结果中也加上了初始值
   ```

   <img src="C:\Users\Yunab\OneDrive\前端学习\ES6\imgs\image-20210711204645370.png" style="zoom:80%;" />



数组去重

```JavaScript
let arr = [12, 34, 34, 342, 345, 34, 123, 345, 45, 12]
let newArr = arr.reduce((prev, next) => {
        // 判断数组中是否存在当前元素，如果不存在的话，再将其添加到数组中
        prev.indexOf(next) == -1 && prev.push(next)
        return prev
    }, []) // 设置迭代初始值为一个空数组
// 原数组不会发生改变
console.log(arr) // [12, 34, 34, 342, 345, 34, 123, 345, 45, 12]
// 去除重复项的新数组
console.log(newArr) // [12, 34, 342, 345, 123, 45]
```

执行结果如下：

<img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/image-20210711204918629.png" alt="image-20210711204918629" style="zoom:80%;" />



### 数组的展开运算符

#### 基本用法

1. 认识展开运算符

```JavaScript
[3, 1, 2];

console.log(Math.min([3, 1, 2])); //NaN (Math.min不能直接计算数组)
console.log(Math.min(3, 1, 2)); //1 (只能接受参数列表)

//要使用Math.min这类函数，需要将数组转换成参数列表形式，和剩余参数正好相反
//[3, 1, 2]->3, 1, 2
```



2. 数组展开运算符的基本用法

   ```javascript
   console.log(Math.min(...[3, 1, 2])); // 1
   
   // 相当于
   console.log(Math.min(3, 1, 2));
   ```
   
    

#### 区分剩余参数的展开运算符

1. 根本区别

```javascript
// 展开运算符
[3,1,2]->3,1,2

// 剩余参数
3,1,2->[3,1,2]
```



2. 区分剩余参数和展开运算符

```javascript
// 剩余参数
const add = (...args) => {
	console.log(args);

	console.log(...args);	// 展开运算符
    //相当于
	console.log(...[1, 2, 3]);
	console.log(1, 2, 3);
};

add(1, 2, 3);

console.log([...[1, 2, 3], 4]); // [1,2,3,4] 展开运算符
// [1, 2, 3]->1,2,3
```



#### 数组展开运算符的应用

1. 复制数组

```javascript
const a = [1, 2];

//b只是a的引用，并没有复制a
const b = a;
a[0] = 3;
console.log(b); [3,2]


const c = [...a];
//相当于
const c = [1, 2];
a[0] = 3;
console.log(a); // [3,2]
console.log(c); // [1,2]
```



2. 合并数组

```javascript
const a = [1, 2];
const b = [3];
const c = [4, 5];

console.log([...a, ...b, ...c]); //[1,2,3,4,5]
console.log([...b, ...a, ...c]); // [3,1,2,4,5]
console.log([1, ...b, 2, ...a, ...c, 3]); // [1,3,2,1,2,4,5,3]
```



3. 字符串转为数组

```javascript
// 字符串可以按照数组的形式展开
console.log(...'alex'); //alex
console.log('a', 'l', 'e', 'x'); //a l e x 

//字符串传化数组
console.log([...'alex']);
//相当于
console.log('alex'.split(''));

//转化后可以使用reverse等数组方法
```



4. 常见的类数组转化为数组

```javascript
// arguments

function func() {
	console.log(arguments.push);
	console.log([...arguments]);
}

func(1, 2);

// NodeList

console.log(document.querySelectorAll('p'));
console.log([...document.querySelectorAll('p')].push);
```



### 对象的展开运算法

#### 基本用法

1.  展开对象

```JavaScript
// 对象不能直接展开，必须在 {} 中展开
   
const apple = {
	color: '红色',
	shape: '球形',
	taste: '甜'
};
   
console.log(...apple); //报错
console.log([...apple]); //报错
   
   
// 对象的展开：把属性罗列出来，用逗号分隔，放到一个 {} 中，构成新对象
   
console.log({ ...apple });
console.log({ ...apple } === apple); //false 说明是新对象，复制了原来的对象
```

   


2. 合并对象

```JavaScript
const apple = {
	color: '红色',
	shape: '球形',
	taste: '甜'
};

const pen = {
	color: '黑色',
	shape: '圆柱形',
	use: '写字'
};

console.log({ ...apple, ...pen }); // {color:"黑色", shape:"圆柱形", taste:"甜", use:"写字"}

// 新对象拥有全部属性，相同属性，后者覆盖前者

console.log({ ...pen, ...apple }); // {color:"红色", shape:"球形", use:"写字", taste:"甜", }

// 相当于

console.log({
	use: '写字',
	color: '红色',
	shape: '球形',
	taste: '甜'
});

console.log({ pen, apple }); //{pen:{...}, apple: {...}}
console.log({ ...pen, apple }); // {color:"黑色", shape:"圆柱形", use:"写字", apple:{...}}
```



#### 注意事项

1. 空对象的展开

```javascript
// 如果展开一个空对象，则没有任何效果

console.log({ ...{} }); // {}
console.log({ ...{}, a: 1 }); // {a: 1}
```

 

2. 非对象的展开

```javascript
// 如果展开的不是对象，则会自动将其转为对象，再将其属性罗列出来

console.log({ ...1 }); // {}

console.log(new Object(1)); // Nubmer {1}

console.log({ ...undefined }); // {}

console.log({ ...null }); // {}

console.log({ ...true }); // {}


// 如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象

console.log({ ...'alex' }); // {0: "a", 1: "l", 2: "e", 3: "x"}

console.log([...'alex']); // ["a", "l", "e", "x"]

console.log(...'alex'); // a l e x

console.log({ ...[1, 2, 3] }); //{0: 1, 1: 2, 2: 3}
```



3. 对象中对象属性的展开

```javascript
// 不会展开对象中的对象属性

const apple = {
	feature: {
		taste: '甜'
	}
};

const pen = {
	feature: {
		color: '黑色',
		shape: '圆柱形'
	},
	use: '写字'
};

console.log({ ...apple });//{feature:{...}}
console.log({ ...apple, ...pen }); // {feature:{...}, use:"写字"} feature里只有color和shape，没有taste

// 相当于

console.log({
	feature: {
		color: '黑色',
		shape: '圆柱形'
	},
	use: '写字'
});
```



#### 应用

1. 复制对象

```javascript
const a = { x: 1, y: 2 };

const c = { ...a };
console.log(c, c === a); //{x:1, y:2} false
```



2. 用户参数和默认参数   

```javascript
const logUser = ({
	username = 'ZhangSan',
	age = 0,
	sex = 'male'
} = {}) => {console.log(username, age, sex);};


const logUser = userParam => {
	const defaultParam = {
		username: 'ZhangSan',
		age: 0,
		sex: 'male'
	};
	//合并用户传参和默认参数
	const param = { ...defaultParam, ...userParam };
    //如果用户没有传参，相当于
	const param = { ...defaultParam, ...undefined };
	
    //使用时如果不想用param., 可以解构
    console.log(param.username);
	const { username, age, sex } = { ...defaultParam, ...userParam };
	console.log(username, age, sex);
};

logUser();
```

------



## Set和Map

### Set

1. 什么是 Set


```JavaScript
// 集合
// 数组是一系列有序（对应index）的数据集合
// Set 是一系列无序、没有重复值的数据集合
```

   

2. 理解 Set

```JavaScript
//两种创建新数组的形式
console.log([1, 2, 1]);
console.log(new Array(1, 2, 1));

//Set需要使用new来创建
const s = new Set();
//添加成员(add方法一次只能添加一个)
s.add(1);
s.add(2);
console.log(s); // Set(2) {1,2}

// Set 中不能有重复的成员
s.add(1);
console.log(s); // Set(2) {1,2}

// Set 没有下标去标示每一个值，所以 Set 是无序的，也不能像数组那样通过下标去访问 Set 的成员
```



#### Set实例的方法和属性

1. 方法

```JavaScript
// add
const s = new Set();
//add可以连续后缀
s.add(1).add(2).add(2);
console.log(s); // Set(2) {1,2 }


// has 判断Set中是否有某元素
console.log(s.has(1)); //true
console.log(s.has(3)); //false


// delete
s.delete(1);

// 使用 delete 删除不存在的成员，什么都不会发生，也不会报错
s.delete(3);
console.log(s); //Set(1) {2}


// clear 全部删除
s.clear();
console.log(s); // Set(0) {}


// forEach 遍历
s.forEach(function (value, key, set) { //value是Set中每个成员，在Set中key和value相同，set就是set本身
	// Set 中 value = key
	console.log(value, key, set === s); //1 1 true //2 2 true
	console.log(this); //#document
}, document);

s.forEach(function (value, key, set) {
	console.log(this); //Window
});

s.forEach(function (value, key, set) => {
	console.log(this); //Window (回调函数是箭头函数时，this指向不看第二项参数)
}, document);

// 按照成员添加进集合的顺序遍历
```



2. 属性

```JavaScript
// size
console.log(s.size); // 2
console.log(s); //Set(2) {1, 2}
```



#### Set构造函数的参数

```html
<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
  <title>Set 构造函数的参数</title>
 </head>
 <body>
    <p>1</p>
    <p>2</p>
    <p>3</p>
    <script>
	... 
  </script>
 </body>
</html>
```

1. 数组

```javascript
const s = new Set([1, 2, 1]);
console.log(s);
```



2. 字符串、arguments、NodeList、Set 等

```javascript
console.log(new Set('hi')); //Set(2) {"h", "i"}

function func() {
	console.log(new Set(arguments));
}

func(1, 2, 1); // Set(2) {1, 2}

console.log(new Set(document.querySelectorAll('p'))); //Set(3) {p, p, p}

const s = new Set([1, 2, 1]);
console.log(new Set(s) === s); //false 复制了一个Set，但不是同一个
console.log(s);
```



#### Set的注意事项

1. 判断重复的方式

```javascript
const s = new Set([1, 2, 1]);
console.log(1 === 1); //true
console.log(NaN === NaN); //false

// Set 对重复值的判断基本遵循严格相等（===）
// 但是对于 NaN 的判断与 === 不同，Set 中 NaN 等于 NaN
const s = new Set([NaN, 2, NaN]);
console.log(s); //Set(2) {NaN, 2}

//对于对象成员的判断
const s = new Set();
s.add({})
console.log(s); //Set(1) {{...}}

const s = new Set();
s.add({}).add({});
console.log(s); //Set(2) {{...}, {...}}

console.log({} === {}); //false
```



2. 什么时候使用 Set

   ① 数组或字符串去重时

   ② 不需要通过下标访问，只需要遍历时

   ③ 为了使用 Set 提供的方法和属性时（add delete clear has forEach size 等）



#### Set的应用

```html
<body>
    <p>1</p>
    <p>2</p>
    <p>3</p>
    <script>
   ...
  </script>
 </body>
```

1. 数组去重

```javascript
// [1, 2, 1];

const s = new Set([1, 2, 1]);
console.log(s);

//可以通过forEach把Set转成数组
s.forEach

//也可通过展开运算符将Set转成数组
console.log(...s); // 1 2
console.log([...s]); //[1,2]
console.log([...new Set([1, 2, 1])]); // [1, 2] 完成去重
```



2. 字符串去重

```javascript
// 'abbacbd';

const s = new Set('abbacbd');
//使用数组转字符串
console.log([...s].join('')); //abcd

console.log([...new Set('abbacbd')].join(''));
```



3. 存放 DOM 元素

```javascript
console.log(document.querySelectorAll('p')); //NodeList(3) [p,p,p]

const s = new Set(document.querySelectorAll('p'));
console.log(s); //Set(3) {p,p,p}

//通过set的forEach遍历元素并做修改
s.forEach(function (elem) {
	console.log(elem); //<p>1</p> <p>2</p> <p>3</p>
	elem.style.color = 'red';
	elem.style.backgroundColor = 'yellow';
});
```



### Map

1. 认识 Map

```javascript
// 映射
// Map 和对象都是键值对的集合
// 键->值，key->value

const person = {
	name: 'alex',
	age: 18
};

const m = new Map();
m.set('name', 'alex');
m.set('age', 18);
console.log(m); // Map(2) {"name" => "alex", "age" => 18}
```



2. Map 和对象的区别

```javascript
// 对象一般用字符串当作键

const obj = {
	name: 'alex', //虽然name这样的键名没有打引号，但这里是合法省略，其实就是字符串
	true: 'true',
	[{}]: 'object'
};

console.log(obj); {name:"alex", true:"true", [object Object]:"object"}
console.log({}.toString()); //object Object

// 基本数据类型：数字、字符串、布尔值、undefined、null
// 引用数据类型：对象（[]、{}、函数、Set、Map 等）
// 以上都可以作为 Map 的键

const m = new Map();
m.set('name', 'alex');
m.set(true, 'true'); //这里的键是布尔值 true 而不是字符串
m.set({}, 'object'); //键是 {...}
m.set(new Set([1, 2]), 'set');
m.set(undefined, 'undefined');

console.log(m);
```



#### Map实例的属性和方法

1. 方法

```javascript
// set （可看作是Set中add方法）
const m = new Map();

// Map使用 set 添加的新成员，键如果已经存在，后添加的键值对覆盖已有的

m.set('age', 18).set(true, 'true').set('age', 20);
console.log(m); //Map(2) {"age" => 20, true =>"true"}

// Set中没有get方法，但Map中可以
// get
console.log(m); // Map(2) ...
console.log(m.get('age')); // 20

// get 获取不存在的成员，返回 undefined
console.log(m.get('true')); //undefined
console.log(m.get(true)); // true


// has
console.log(m.has('age')); //true
console.log(m.has('true')); //false

// delete
m.delete('age');
m.delete('name');


// 使用 delete 删除不存在的成员，什么都不会发生，也不会报错
console.log(m);

// clear 清空
m.clear();
console.log(m); // Map(0)

// forEach
m.forEach(function (value, key, map) {
	console.log(value, key, map === m); //Map(2) {...} true
	console.log(this); //#document
}, document);
```



2. 属性

```javascript
// size
// 对象没有类似的属性

console.log(m.size);
```



#### Map构造函数的参数

1. 数组

```javascript
console.log(new Map(['name', 'alex', 'age', 18])); //报错 没有键值对

// 只能传二维数组，而且必须体现出键和值
console.log(
	new Map([
		['name', 'alex'],
		['age', 18]
	])
);
```



2. Set、Map 等

```javascript
// Set
// Set 中也必须体现出键和值

const s = new Set([
	['name', 'alex'],
	['age', 18]
]);

console.log(new Map(s));
console.log(s);

// Map
// 复制了一个新的 Map

const m1 = new Map([
	['name', 'alex'],
	['age', 18]
]);

console.log(m1);
const m2 = new Map(m1); //复制但不相同
console.log(m2, m2 === m1); //false
```



#### Map的注意事项

1. 判断键名是否相同的方式

```javascript
// 基本遵循严格相等（===）
// 例外就是 NaN，Map 中 NaN 也是等于 NaN

console.log(NaN === NaN); //false

const m = new Map();
m.set(NaN, 1).set(NaN, 2);

console.log(m); //Map(1) {NaN => 2}
```



2. 什么时候使用 Map

```javascript
// 如果只是需要 key -> value 的结构，或者需要字符串以外的值做键，使用 Map 更合适
// forEach for in
// size

// 只有模拟现实世界的实体时，才使用对象
const person = {};
```



#### Map的应用

```html
<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
  <title>Map 的应用</title>
 </head>
 <body>
    <p>1</p>
    <p>2</p>
    <p>3</p>
    <script>
   	const [p1, p2, p3] = document.querySelectorAll('p');
	const m = new Map();
    m.set(p1, 'red');
    m.set(p2, 'green');
    m.set(p3, 'blue');
    console.log(m); //Map(3) { p => "red", p => "green", p => "blue"}
    
    //或者
    const m = new Map([
        [p1, 'red'],
        [p2, 'green'],
        [p3, 'blue']
    ]);
        
    //将key（elem）的颜色变成value（color）值
    m.forEach((color, elem) => {
   		elem.style.color = color;
	});

	//对象作为值
   const m = new Map([
	[
		p1,
		{
			color: 'red',
			backgroundColor: 'yellow',
			fontSize: '40px'
		}
	],
	[
		p2,
		{
			color: 'green',
			backgroundColor: 'pink',
			fontSize: '40px'
		}
	],
	[
		p3,
		{
            color: 'blue',
			backgroundColor: 'orange',
			fontSize: '40px'
		}
	]
	]);

   m.forEach((propObj, elem) => {
       //遍历对象属性
		for (const p in propObj) {
			elem.style[p] = propObj[p];
		}
	});
   
  </script>
 </body>
</html>
```

------



## 遍历器与for...of循环

### 遍历器是什么

1. Iterator 的作用

```javascript
// Iterator：遍历器（迭代器）

// for()
// [1,2].forEach
// new Set().forEach

// Iterator 也是用来遍历的
```

   

2. 寻找 Iterator

```javascript
console.log([1,2]) //在原型中，有Symbol(Symbol.iterator),用于创建基本类型
console.log(Iterator);
console.log([1, 2][Symbol.iterator]());//Array Iterator {}

const it = [1, 2][Symbol.iterator]();
console.log(it); ////Array Iterator {}
```

   

3. 使用 Iterator

```javascript
const it = [1, 2][Symbol.iterator]();
console.log(it.next()); // {value: 1, done: false} (value表示当前遍历中数组中的值， done表示遍历是否完成)
console.log(it.next()); // {value: 2, done: false}
console.log(it.next()); // {value: undefined, done: true}
console.log(it.next()); // {value: undefined, done: true}

// it：可遍历对象（可迭代对象）
// Symbol.iterator：可遍历对象的生成方法
```



4. 什么是 Iterator

```JavaScript
// Symbol.iterator（可遍历对象的生成方法） -> it（可遍历对象） -> it.next() -> it.next() -> ...（直到 done 为 true）
```



#### Symbol详解

- 概念：Symbol是ES6引入的一种新的基本数据类型，用于表示一个独一无二的值，它与undefined、null、Number（数值）、String（字符串）、Boolean（布尔值）、Object（对象）并列，是JS中第7种**基本数据类型**

创建Symbol值：

```JavaScript
const a = Symbol();
console.log(a);  //Symbol()
console.log(typeof a) // symbol
```

使用Symbol函数可以生成一个Symbol类型的值



- 语法规范

  1. 基本语法

     Symbol的值是唯一的，创建两个Symbol值，即使控制台输出一样，但两个Symbol值是不相等的

     ```JavaScript
     let a = Symbol();
     let b = Symbol();
     console.log(a);  //Symbol()
     console.log(b);  //Symbol()
     console.log(a === b) // false
     ```

  2. 在调用Symbol的是时候传入一个字符串作为当前Symbol变量的描述，可区分不同的Symbol变量

     ```JavaScript
     let a = Symbol("symbol1");
     let b = Symbol("symbol2");
     console.log(a); //Symbol("symbol1")
     console.log(b); //Symbol("symbol2")
     ```



注意：Symbol是基本数据类型，调用Symbol时不可以使用new关键字。

```JavaScript
//报错，Symbol is not a constructor
const a = new Symbol();
```



- Symbol属性的遍历

  Symbol类型的变量作为对象属性时，该属性不会出现在for...in、for...of循环中

  ```JavaScript
  let s1 = Symbol('a');
  let s2 = Symbol('b');
  // 由于 s1 和 s2 是一个变量，而不是字符串，因此需要使用中括号括起来（否则它会被当做字符串使用）
  let a = {
      name: "Yuna",
      [s1]: 24,
      [s2]: function(){}
  }
  
  //for...in方式遍历obj对象时，Symbol类型的属性没有输出，只输出name属性， s1，s2属性不会被遍历出来。
  ```

  

- Symbol.for(), Symbol.keyFor()

  1. Symbol.for(): Symbol 提供的一种可以创建相同Symbol的机制，使用Symbol.for()方法进行注册。

     ```JavaScript
     let a = Symbol.for('imooc');  //全局注册了以"imooc"为描述符的 Symbol
     //由于描述符"imooc"已被注册到全局，因此这里创建的 Symbol 与上面是同一个
     let b = Symbol.for('imooc');  
     console.log(a === b) // true
     
     //通过该方法生成的Symbol会在当前作用域中注册指定的描述符，之后再次通过Symbol.for()传入相同的描述符时，就可以得到相同的Symbol值，所以变量a和b是相同的，比较后返回结果为true。
     ```

     

  2. Symbol.keyFor(): 返回一个全局注册的Symbol的描述符

     ```JavaScript
     let a = Symbol.for('imooc');
     let res = Symbol.keyFor(a)
     console.log(res) // imooc
     
     //返回结果是已经注册过的变量a的描述符imooc
     ```

     

- Symbol的作用

  由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

  ```JavaScript
  let s1 = Symbol();
  let s2 = Symbol()
  const obj = {
      age: 16,
      age: 19,
      [s1]: 'Hello!',
      [s2]: 'world'
  };
  console.log(obj)
  
  //由于age是字符串类型的,同名属性会被覆盖，所以obj对象中只会有一个age属性，而Symbol值是唯一的，即使控制台中输出结果看起来是一样的，但他们并不表示同一个值，所以obj中s1和s2都未添加到obj对象中
  ```

  <img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/image-20210715231845272.png" alt="image-20210715231845272" style="zoom:80%;" />



为了方便区分，可以给Symbol值添加描述

```JavaScript
let s1 = Symbol('s1');
let s2 = Symbol('s2')
const obj = {
    age: 16,
    age: 19,
    [s1]: 'Hello!',
    [s2]: 'world'
};
console.log(obj)

//obj中添加了两个Symbol值作为属性名，描述分别为s1，s2
```

<img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/image-20210715232004267.png" alt="image-20210715232004267" style="zoom:80%;" />



- 常用内置的Symbol值：Symbol.iterator

  对象的Symbol.iterator属性，指向该对象的默认遍历器方法，凡是具有[Symbol.iterator]方法的对象都是可遍历的，可以使用for...of循环依次输出对象的每个属性数组和类数组，以及ES6新增的Map、Set等都原生部署了该方法，因此它们都可遍历

  ```JavaScript
  for(var item of [1,2,3]){
    console.log(item); //依次输出 1，2，3
  }
  ```

  

- Symbol与基本数据类型转换

  1. Symbol不能转成数字

     ```JavaScript
     let s1 = Symbol('1');
     // 报错
     console.log(Number(s1))
     
     //使用Number对Symbol值转换会出现报错
     ```

  2. 可以转成布尔值和字符串

     ```JavaScript
     let s1 = Symbol('1');
     console.log(typeof s1) // symbol
     let str = String(s1)
     console.log(typeof str) // string
     let bool = Boolean(s1)
     console.log(typeof bool) // boolean
     
     //Symbol值可以通过String转成字符串形式，通过Boolean转成布尔值
     ```

     

- 总结：一般Symbol的使用是为了防止键值属性被覆盖。使用Symbol作为对象属性时，需要使用方括号语法去访问对应的属性，而不是字符串。



#### Iterator解惑

1. 为什么需要 Iterator 遍历器

```JavaScript
// 遍历数组：for 循环和 forEach 方法
// 遍历对象：for in 循环


// Iterator 遍历器是一个统一的遍历方式

console.log([][Symbol.iterator]()); //Array Iterator {} (数组天生就有iterator)
console.log({}[Symbol.iterator]); //undefined （对象天生并没有iterator）
```



2. 如何更方便的使用 Iterator

```JavaScript
// 原始方法：Symbol.iterator->it->next()
// 但我们一般不会直接使用 Iterator 去遍历

// 而是使用封装好的 for..of
```



### for...of的用法

1. 认识 for...of

```JavaScript
const arr = [1, 2, 3];
const it = arr[Symbol.iterator]();
console.log(it.next()); //{value:1, done:false}
console.log(it.next());	//{value:2, done:false}
console.log(it.next());	//{value:3, done:false}
console.log(it.next());	//{value:undefined, done:true}

let next = it.next();
console.log(next); // {value:1, done:false}

//通过while遍历
while (!next.done) {
	console.log(next.value);
	next = it.next();
	console.log(next);
}

//通过for..of遍历
for (const item of arr) {
	console.log(item); // 1 2 3
 }

// for...of 循环只会遍历出那些 done 为 false 时，对应的 value 值
```



2. 与 break、continue 一起使用

```javascript
const arr = [1, 2, 3];

for (const item of arr) {
	if (item === 2) {
		break; //当item===2时，停止遍历
	}
	console.log(item); //1
}

for (const item of arr) {
	if (item === 2) {
		continue; //跳过2，继续遍历
	}
	console.log(item); //1 3
}

//相当于
arr.forEach()
```



3. 在 for...of 中取得数组的索引

```javascript
const arr = [1, 2, 3];

// keys() 得到的是索引的可遍历对象，可以遍历出索引值

console.log(arr.keys()); //Array Iterator{}

for (const key of arr.keys()) {
    console.log(key); //0 1 2 遍历索引
}

// values() 得到的是值的可遍历对象，可以遍历出值

for (const value of arr.values()) {
	console.log(value); //1 2 3
}

for (const value of arr) {
	console.log(value); //1 2 3
}


// entries() 得到的是索引+值组成的数组的可遍历对象

for (const entries of arr.entries()) {
	console.log(entries); //[0,1] [1,2] [2,3]
}

for (const [index, value] of arr.entries()) {
	console.log(index, value);
}
```



### 原生可遍历和非原生可遍历



```html
<body>
    <p>1</p>
    <p>2</p>
    <p>3</p>
    <script>
   ...
  </script>
 </body>
```



1. 什么是可遍历

- 只要有 Symbol.iterator 方法，并且这个方法可以生成可遍历对象，就是可遍历的
- 只要可遍历，就可以使用 for...of 循环来统一遍历



2. 原生可遍历的有哪些
   - 数组
   - 字符串
   - Set
   - Map
   - arguments
   - NodeList

```javascript

for (const item of [1, 2, 3]) {
	console.log(item); //1 2 3
}

for (const item of 'hi') {
	console.log(item); // h i
}

for (const item of new Set([1, 2])) {
	console.log(item); //1 2
}

for (const elem of document.querySelectorAll('p')) {
	console.log(elem); // <p>1</p> <p>2</p> <p>3</p>
	elem.style.color = 'red';
}
```

  

3. 非原生可遍历的有哪些
   - 一般的对象

```javascript
// 一般的对象

const person = { sex: 'male', age: 18 };
console.log(person[Symbol.iterator]()); //报错


//给对象添加iterator方法，一般不会用
// 利用{next()} {value,done}
person[Symbol.iterator] = () => {

	let index = 0;
	
    return {
		next() {
			index++;
			if (index === 1) {
				return { //遍历的顺序自定义
					value: person.age,
					done: false
				};
			} else if (index === 2) {
                return {
					value: person.sex,
					done: false
				};
			} else {
				return {
					done: true
				};
			}
		}
	};
};

for (const item of person) {
	console.log(item); //18 male
}


// 有 length 和索引属性的对象

const obj = {
	'0': 'alex',
	'1': 'male',
	length: 2
};


obj[Symbol.iterator] = () => {
	let index = 0;
	return {
		next() {
			let value, done;
			if (index < obj.length) {
				value = obj[index];
				done = false;
			} else {
				value = undefined;
				done = true;
			}

			index++;
			return {
				value,
				done
			};
		}
	};
};

//或者直接借用数组的iterator方法
obj[Symbol.iterator] = Array.prototype[Symbol.iterator];

for (const item of obj) {
	console.log(item); //alex male
}
```



### 使用了Iterator的场合

原生可遍历的

- Array 数组

- String 字符串

- Set

- Map

- 函数的 arguments 对象

- NodeList 对象

- for...of



1. 数组的展开运算符

```javascript
console.log(...[1, 2, 3]);//1 2 3 (数组展开利用了遍历机制)
console.log(1, 2, 3);

console.log(...'str');
console.log(...new Set([1, 2, 3]));

console.log(...{}); ×
```

  

2. 数组的解构赋值

```javascript
const [a, b] = [1, 2];
const [a, b] = [...[1, 2]];

const [a, b] = 'hi';

const [a, b] = [...'hi'];
const [a, b] = [...new Set([3, 4])];

console.log(a, b);
```



3. Set 和 Map 的构造函数

```javascript
new Set(iterator)
new Map(iterator)
```



------

## ES6新增方法



### 字符串的新增方法



#### includes()

判断字符串中是否含有某些字符



1. 基本用法

```JavaScript
console.log('abc'.includes('a')); // true

console.log('abc'.includes('ab')); // true

console.log('abc'.includes('bc')); // true

console.log('abc'.includes('ac')); // false (需要连续)
```



2. 第二个参数

```JavaScript
// 表示开始搜索的位置，默认是 0

console.log('abc'.includes('a')); // true

console.log('abc'.includes('a', 0)); // true

console.log('abc'.includes('a', 1)); // false （从b开始搜索）
```



3. 应用

```javascript
//通过点击目标，给url链接增加指定字符
// https://www.imooc.com/course/list
// https://www.imooc.com/course/list?c=fe&sort=pop&name=value

let url = 'https://www.imooc.com/course/list?';

const addURLParam = (url, name, value) => {
	url += url.includes('?') ? '&' : '?'; //如果url中包含？，增加 '&'，如果没有则添加'?'
	url += `${name}=${value}`; //模板字符串
	return url;
};

url = addURLParam(url, 'c', 'fe');
console.log(url); //https://www.imooc.com/course/list?c=fe

url = addURLParam(url, 'sort', 'pop');
console.log(url); //https://www.imooc.com/course/list?c=fe&sort=pop
```



#### padStart() 和padEnd()

补全字符串长度



1. 基本用法

```javascript
console.log('x'.padStart(5, 'ab'));//ababx (字符串总共5位，用ab来补)

console.log('x'.padEnd(5, 'ab')); //xabab

console.log('x'.padEnd(4, 'ab')); //xaba
```



2. 注意事项

```javascript
// 原字符串的长度，等于或大于最大长度，不会消减原字符串，字符串补全不生效，返回原字符串

console.log('xxx'.padStart(2, 'ab')); //xxx

console.log('xxx'.padEnd(2, 'ab')); //xxx


// 用来补全的字符串与原字符串长度之和超过了最大长度，截去超出位数的补全字符串，原字符串不动

console.log('abc'.padStart(10, '0123456789')); //0123456abc

console.log('abc'.padEnd(10, '0123456789')); //abc0123456


// 如果省略第二个参数，默认使用空格补全长度

console.log('x'.padStart(4)); //    x (空格填充)

console.log('x'.padEnd(4)); //x    (空格填充)
```



3. 应用

```javascript
// 显示日期格式

// 2020
// 10
// 10


// 2020-10-10
// 2020-01-01

console.log('10'.padStart(2, 0)); //10
console.log('1'.padStart(2, 0)); //01
```



#### trimStart() 和 trimEnd()

清除字符串的首或尾空格，中间的空格不会清除



1. 基本用法

```javascript
const s = ' a b c ';
console.log(s); //·a·b·c· （·代表空格）

console.log(s.trimStart()); //a·b·c· 
console.log(s.trimLeft()); //a·b·c·

console.log(s.trimEnd()); //·a·b·c
console.log(s.trimRight()); //·a·b·c

console.log(s.trim()); //a·b·c
```



2. 应用

```html
<body>
    <input type="text" id="username" />
    <input type="submit" value="提交" id="btn" />
    <script>
    ...
    </script>
</body>
```



```javascript
//应用在表单提交
const usernameInput = document.getElementById('username');
const btn = document.getElementById('btn');


btn.addEventListener(
	'click',
	() => {
	console.log(usernameInput.value);

	// 验证
	console.log(usernameInput.value.trim()); //过滤 纯空格 的内容
	if (usernameInput.value.trim() !== '') { //判断是否为空
        // 可以提交
		console.log('可以提交');
	} else {
		// 不能提交
		console.log('不能提交');
	}

	// 手动提交 (之后利用AJAX提交)
	},
	false
);
```



#### replaceAll 方法

1. 为什么引入replaceAll方法？

   由于字符串的实例方法 **replace()** 方法只能替换第一个匹配的内容，如：

   ```JavaScript
   'aabbf'.replace('b', '_'); 
   ```

   输出的结果为：`aa_bf`。只替换了第一个b。

   

   若要替换所有内容，就得使用正则表达式的g修饰符。如：

   ```JavaScript
   'aabbcc'.replace(/b/g,'_');
   ```

   输出结果为：`aa__cc`.

   由于正则表达式并不直观、方便。所以，引入replaceAll()方法，可以一次性替换所有匹配的项目。如：

   ```javascript
   'aaddf'.replaceAll('d','3');
   ```

   输出结果为：`aa33f`.



2. replaceAll() 语法规范   

```JavaScript
String.prototype.replaceAll(searchValue, replacement);
```

- searchValue： 表示搜索模式， 可以是一个字符串， 也可以是一个全局的正则表达式（ 带有g修饰符）。        

- replacement： 表示替换的文本， 是一个字符串示例：    

```html
<script>        
	const fruits ='苹果+草莓+';        
	const fruitsWithBanana = fruits.replace(/\+/g,'香蕉');
    console.log(fruits); //苹果+草莓+
	console.log(fruitsWithBanana); //苹果香蕉草莓香蕉   
	
    //replaceAll()会将所有匹配的内容 + 替换为香蕉， 返回一个新的字符串，不会改变原字符串
</script>
```



注意事项：

- 如果searchValue是一个不带g修饰符的正则表达式，replaceAll()会报错，但是replace()不会报错。

  ```JavaScript
  let str = "aabbcc";
  
  // /b/不带有g修饰符，会导致replaceAll()报错
  str.replace(/b/, '_') //不报错
  str.relaceAll(/b/, '_') //报错
  ```

  

3. repalceAll() 应用场景

   去除字符串多余的文字。

   ```JavaScript
   const str1 ='广东省，福建省，浙江省，湖南省，河北省，河南省，……';
   
   //使用replaceAll将“省”字全部替换为空白字符
   const str = str1.replaceAll("省", "");
   ```

   

replaceAll()的主要目的是给开发者提供一个简单直接的操作方式，可以一次性直接替换所有匹配的内容。



### 数组的新增方法

### includes()

1. 基本用法

```javascript
// 判断数组中是否含有某个成员

console.log([1, 2, 3].includes('2')); //false

console.log([1, 2, 3].includes(2)); //true


// 第二个参数表示搜索的起始位置，默认值是 0

console.log([1, 2, 3].includes(2, 2)); //false


// 基本遵循严格相等（===）,但是对于 NaN 的判断与 === 不同，includes 认为 NaN === NaN

console.log(NaN === NaN); // false

console.log([1, 2, NaN].includes(NaN)); //true
```



2. 应用

```javascript
// 去重

// [1, 2, 1];

const arr = [];

for (const item of [1, 2, 1]) {
	if (!arr.includes(item)) {
		arr.push(item);
	}
}

console.log(arr); //[1, 
2]
```



### Array.from()

**将其他数据类型转换成数组**



1. 基本用法

```javascript
console.log(Array.from('str')); //["s", "t", "r"]
```

   

2. 哪些可以通过 Array.from() 转换成数组

   

   2.1. 所有可遍历的

```javascript
// 数组、字符串、Set、Map、NodeList、arguments

console.log(Array.from(new Set([1, 2, 1]))); //[1, 2]

//相当于展开，一般更常用此方法
console.log([...new Set([1, 2, 1])]); // [1, 2]
```



​	2.2. 拥有 length 属性的任意对象

```javascript
const obj = {
	length: 1
};
console.log([...obj]); // × 报错 （不可遍历则不能展开）
console.log(Array.from(obj)); //[undefined]


const obj = {
	'0': 'a',
	'1': 'b',
	name: 'Alex',
	length: 3
};

console.log(Array.from(obj)); // ["a", "b", undefined] 键名不是数字的，不会被转换
```

  

3. 第二个参数

```javascript
// 作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组

console.log(
	[1, 2].map(value => {
		return value * 2;
	})
); // [2, 4]

console.log(Array.from('12', value => value * 2)); //[2, 4]

console.log(Array.from('12').map(value => value * 2)); //[2, 4]
```



4. 第三个参数

```javascript
Array.from('12',value => {
	console.log(this); //Window Window (箭头函数)
},document);

Array.from(
	'12',
	
    function () {
		console.log(this); //#document #document
	},
	document
);
```



### find() 和 findIndex()



- find()：找到满足条件的一个**立即返回值**

- findIndex()：找到满足条件的一个，**立即返回其索引**



1. 基本用法

```javascript
console.log(
	[1, 5, 10, 15].find((value, index, arr) => {
		console.log(value, index, arr); 
        //1  0 Array(4) 
        //5 1 Array(4) 
        //10 2 Array(4) 
        //15 3 Array(4)
        
		console.log(this); //Window
		return value > 9;
      }, document)
); // 10

[1, 5, 10, 15].find(function (value, index, arr) {
	console.log(this); //#document

	return value > 9;
}, document); //2

console.log(
	[1, 5, 10, 15].findIndex((value, index, arr) => {
		return value > 9;
	}, document)
);
```

  

2. 应用

```javascript
const students = [
	{
		name: '张三',
		sex: '男',
		age: 16
	},

	{
		name: '李四',
		sex: '女',
		age: 22
	},

	{
		name: '王二麻子',
		sex: '男',
		age: 32
	}
];

console.log(students.find(value => value.sex === '女')); //{name:"李四", sex:"女", age:22}
console.log(students.findIndex(value => value.sex === '女')); //1
```





### 对象的新增方法



### Object.assign()

**用来合并对象**



1. 基本用法

```javascript
// Object.assign(目标对象, 源对象1,源对象2,...): 目标对象

const apple = {
	color: '红色',
	shape: '圆形',
	taste: '甜'
};

const pen = {
	color: '黑色',
	shape: '圆柱形',
	use: '写字'
};

// Object.assign 直接合并到了第一个参数中，返回的就是合并后的对象
console.log(Object.assign(apple, pen)); //{color: "黑色", shape:"圆柱形", taste:"甜", use:"写字"}

console.log(apple); //{color: "黑色", shape:"圆柱形", taste:"甜", use:"写字"}
console.log(Object.assign(apple, pen) === apple); // true

//看起来与以下展开合并结果一致，但展开之后返回的是新对象
console.log({ ...apple, ...pen }); //{color: "黑色", shape:"圆柱形", taste:"甜", use:"写字"}
console.log({ ...apple, ...pen }===apple); //false



// 如果不想合并到第一个，只要传一个空对象在第一个参数就可以

console.log(Object.assign({}, apple, pen));
console.log(apple); //{color: "红色", shape:"圆形", taste:"甜"}

```



2. 注意事项

     2.1. 基本数据类型作为源对象(希望被合并的对象)

```javascript
// 与对象的展开类似，先转换成对象，再合并
//Object.assign(目标对象，源对象1，源对象2，……);

console.log(Object.assign({}, undefined)); // {}

console.log(Object.assign({}, null)); // {}

console.log(Object.assign({}, 1)); // {}

console.log(Object.assign({}, true)); // {}

console.log(Object.assign({}, 'str')); // {0: "s", 1: "t", 2: "r"}
```

  

​	2.2. 同名属性的替换

```javascript
// 后面的直接覆盖前面的同名属性，不管值的数据类型

const apple = {
	color: ['红色', '黄色'],
	shape: '圆形',
	taste: '甜'
};

const pen = {
	color: ['黑色', '银色'],
	shape: '圆柱形',
	use: '写字'
};

console.log(Object.assign({}, apple, pen)); //{color: ["黑色","银色"], shape:"圆柱形", taste:"甜", use:"写字"}
```



3. 应用

```javascript
// 合并默认参数和用户参数

const logUser = userOptions => {
	const DEFAULTS = {
		username: 'ZhangSan',
		age: 0,
		sex: 'male'
	};

	const options = Object.assign({}, DEFAULTS, userOptions);
	
    //传空对象或者空参数相当于传入undefined
	//const options = Object.assign({}, DEFAULTS, undefined);

	console.log(options);
};

logUser(); //{username:"Zhangsan", age: 0, sex: "male"}

logUser({}); //{username:"Zhangsan", age: 0, sex: "male"}

logUser({ username: 'Alex' }); //{username:"Zhangsan", age: 0, sex: "male"}
```



### Object.keys(), Object.values(), Object.entries()

1. 基本用法

```javascript
const person = {
	name: 'Alex',
	age: 18
};

console.log(Object.keys(person)); //["name", "age"]
console.log(Object.values(person)); // ["Alex",18]
console.log(Object.entries(person)); // [Array(2), Array(2)] // [["name", "Alex"],["age",18]]
```



2. 与数组类似方法的区别

```javascript
// 数组的 keys()、values()、entries() 等方法是实例方法，返回的都是 Iterator
// 对象的 Object.keys()、Object.values()、Object.entries() 等方法是构造函数方法，返回的是数组

console.log([1, 2].keys()); //Array Iterator{}

console.log([1, 2].values()); //Array Iterator{}

console.log([1, 2].entries()); //Array Iterator{}
```



3. 使用 for...of 循环遍历对象

```javascript
const person = {
	name: 'Alex',
	age: 18
};

for (const key of Object.keys(person)) {
	console.log(key);
    //name
    //age
}

for (const value of Object.values(person)) {
	console.log(value);
    //Alex
    //18
}

for (const entries of Object.entries(person)) {
	console.log(entries);
    //["name"," Alex"]
    //["age", 18]
}

//利用解构
for (const [key, value] of Object.entries(person)) {
	console.log(key, value);
    //name Alex
    //age 18
}

// Object.keys()/values()/entires() 并不能保证顺序一定是你看到的样子，这一点和 for in 是一样的
```



------

## Promise



### Promise 基本认识

```html
<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
  <title>Promise 是什么</title>
    <style>
   \* {
 		padding: 0;
		margin: 0;
   	}

	\#box {
		width: 300px;
		height: 300px;
		background-color: red;
		transition: all 0.5s;
		}
  </style>
     
 </head>
 <body>
    <div id="box"></div>
     
    <script>
	...
  </script>
     
 </body>
</html>
```

 

1. 认识 Promise

```javascript
// Promise 是异步操作的一种解决方案

// 回调函数

//回调函数举例
document.addEventListener(
	'click',() => {
		console.log('这里是异步的');
	},false
);

console.log('这里是同步的');

//console会直接输出 “这里是同步的”
//只有点击文档时，才会输出“这里是异步的”
```



2. 什么时候使用 Promise

```javascript
// Promise 一般用来解决层层嵌套的回调函数（回调地狱 callback hell）的问题

//回调地域举例，html和css参考上面

// 运动

const move = (el, { x = 0, y = 0 } = {}, end = () => {}) => {
	el.style.transform = `translate3d(${x}px, ${y}px, 0)`; //改变x和y轴
    
	el.addEventListener(
 		'transitionend',() => {
    		console.log('end');
    		end();
		},false
	);
};

const boxEl = document.getElementById('box');

document.addEventListener(
	'click',() => {
 		//一步一步的运动，如果运动过多，就会层层嵌套
        move(boxEl, { x: 150 }, () => {
            move(boxEl, { x: 150, y: 150 }, () => {
                move(boxEl, { y: 150 }, () => {
                    move(boxEl, { x: 0, y: 0 });
                });
            });
        });
    },false
);
```



#### 基本用法

1. 实例化构造函数生成实例对象

```JavaScript
// Promise 解决的不是回调函数，而是回调地狱
const p = new Promise(() => {}); //生成Promise需要有回调函数
```



2. Promise 的状态

```JavaScript
const p = new Promise((resolve, reject) => {
	// Promise 有 3 种状态，一开始是 pending（未完成），执行 resolve，变成 fulfilled(resolved)，已成功
	// 执行 reject，变成 rejected，已失败
	// Promise 的状态一旦变化，就不会再改变了
	
    // 状态变化 pending->fulfilled
	resolve();
	
    // 如果没执行 resolve，状态 rejected，如果已经执行resolve，则状态还是fulfilled
	reject();  
});

//注意：只能从pending 变为 fulfilled或rejected，没有从fulfilled变为rejected或rejected变为fulfilled的情况
```



3. then 方法

```JavaScript
p.then(
    () => { //状态变为fulfilled时执行
	console.log('success');
	},	
    () => {//状态变为rejected时执行
		console.log('error');
	}
);
```

   

4. resolve 和 reject 函数的参数

```JavaScript
const p = new Promise((resolve, reject) => {
	//resolve('succ');
	resolve({ username: 'alex' });

	//reject('reason');
	reject(new Error('reason'));
});

p.then(
    data => {
        console.log('success', data); //success {username: 'alex'}
    },
    err => {
        console.log('error', err); //error Error
    }
);

console.log(p);
```



### Promise实例方法

#### then()

```html
<head>
    <meta charset="UTF-8" />
  <title>then()</title>
    <style>
   * {
       padding: 0;
       margin: 0;
   }

   #box {
       width: 300px;
       height: 300px;
       background-color: red;
       transition: all 0.5s;
   }
  </style>
 </head>

 <body>
    <div id="box"></div>
	
     <script>
     ...
     </script>
</body>
```

1. 什么时候执行

- pending->fulfilled 时，执行 then 的第一个回调函数

- pending->rejected 时，执行 then 的第二个回调函数



2. 执行后的返回值

```javascript
// then 方法执行后返回一个新的 Promise 对象

const p = new Promise((resolve, reject) => { //注意这里的（resolve,reject)是回调函数的参数，不是Promise()的第一个参数
    resolve(); //决定 p 的状态
    reject(); //决定 p 的状态
});

const p2 = p.then(
    () => {},
    () => {}
)
console.log(p, p2);
//Promise {<fulfilled>: undefined}
//Promise {<pending>}

console.log(p === p2); // false

//p2 是单独的Promise，所以可以有自己的 then
const p2 = p.then(
    () => {},
    () => {}
).then();

//.then()会返回一个Promise方法，所以可以继续then

const p2 = p.then(
    () => {},
    () => {}
).then().then();

```

  

3. then 方法返回的 Promise 对象的状态改变

```javascript
const p = new Promise((resolve, reject) => {
    reject();
});

p.then(
    () => {
        console.log('success');
    },
    () => {
        console.log('err');
    }
).then( //p.then()的状态决定执行以下哪个函数
    ()=> {
        console.log('success2');
    },
    ()=> {
        console.log('err2');
    }
)
//这里会执行 err success2


const p = new Promise((resolve, reject) => {
    reject();
});

p.then(
    () => {
        console.log('success');
    },
    () => {
        console.log('err');
        // 在 then 的回调函数中，return 后面的东西，会用 Promise 包装一下，
        // 默认返回的永远都是成功状态的 Promise 对象
        return undefined;
        
        // 等价于
        return new Promise(resolve => {
            resolve(undefined);
        });
        
        //如果return 123，这下面会执行 err success2 123
    }
).then(
   	data => { //接受return值
        console.log('success2', data);
    },
    ()=> {
        console.log('err2');
    }
)
//这里会执行 err success2 undefined


//如果要then().then()接受失败参数，则需要自己写一个返回Promise
const p = new Promise((resolve, reject) => {
    reject();
});

p.then(
    () => {
        console.log('success');
    },
    () => {
        console.log('err'); 

        return new Promise((resolve, reject) => {
            reject('reason');
        });
    }).then(
    	data => {
        	console.log('success2', data);
        	return undefined;
    	},
    	err => {
        	console.log('err2', err);
    	}
	).then(
    	data => {
        	console.log('success3', data);
    	},
    	err => {
        	console.log('err3', err);
    	}
	);
//执行结果 err err2 reason success3 undefined
```



4. 使用 Promise 解决回调地狱

```javascript
// 运动

const move = (el, { x = 0, y = 0 } = {}, end = () => {}) => {
    el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    el.addEventListener(
        'transitionend',
        () => {
            end();
        },false
    );
};

const boxEl = document.getElementById('box');

//原始方法
document.addEventListener(
    'click',() => {
        move(boxEl, { x: 150 }, () => {
            move(boxEl, { x: 150, y: 150 }, () => {
                move(boxEl, { y: 150 }, () => {
                    move(boxEl, { x: 0, y: 0 });
                });
            });
        });
    },false
);

//利用Promise改造
const movePromise = (el, point) => {//point表示xy坐标
    return new Promise(resolve => {
        move(el, point, () => {
            resolve(); //每运动一次，会resolve执行then方法
        });
    });
};

document.addEventListener(
    'click',() => {
        movePromise(boxEl, { x: 150 })
       	.then(
            () => {
                return movePromise(boxEl, { x: 0, y: 0 });
            })
        .then(
            () => {
                return movePromise(boxEl, { x: 150, y: 150 });
            })
        .then(() => {
            return movePromise(boxEl, { y: 150 });
        });
    },false
);

```



#### catch()

1. 有什么用

```javascript
//标准的then方法有两个回调
then(
    data => {},
    err => {}
);

//但一般我们只需要用到成功的回调，失败的回调不写
then(data => {});

// 此时就会使用 catch 专门用来处理 rejected 状态
// catch 本质上是 then 的特例

then(null, err => {});
```



2. 基本用法

```javascript
new Promise((resolve, reject) => {
    //resolve(123);
    reject('reason');
})

.then(
    data => {
    	console.log(data);
	}
)
.catch(err => {
    console.log(err);
    return undefined;
    throw new Error('reason');
}) //执行结果为 reason

//相当于
.then(null, err => {
    console.log(err);
});


new Promise((resolve, reject) => {
    //resolve(123);
    reject('reason');
})
.then(
    data => {
    	console.log(data);
	}
)
.catch(err => {
    console.log(err);
    //return undefined; （默认返回undefined，之后的then会执行成功）
    throw new Error('reason');
})
.then(data => {
    console.log(data);
})
.catch(err => {
    console.log(err);
});


// catch() 可以捕获它前面的错误

// 一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误
```



#### finally()

1. 什么时候执行 （实际开放中并不常用）

```javascript
// 当 Promise 状态发生变化时，不论如何变化都会执行，不变化不执行

new Promise((resolve, reject) => {
    //resolve(123);
    reject('reason');
})

.finally(data => {
    console.log(data);
})
.catch(err => {});
//执行结果 undefined （这里只执行了finally，但data为空，因为没有捕获到任何传参）

//finally的使用是在Promise执行后进行收尾操作，比如关闭文档，关闭数据库
```

   

2. 本质

```javascript
// finally() 本质上是 then() 的特例

new Promise((resolve, reject) => {
    resolve(123);
    reject('reason');
})

.finally(data => {
    console.log(data);
})

.catch(err => {});

// 等同于

new Promise((resolve, reject) => {
    resolve(123);
    reject('reason');
})

.then(
    result => {
        return result;
    },
    err => {
        return new Promise((resolve, reject) => {
            reject(err);
        });
    }
)

.then(data => {
    console.log(data);
})

.catch(err => {
    console.log(err);
});
```



### Promise的构造函数方法



#### Promise.resolve() 和 Promise.reject()

1. Promise.resolve()

```JavaScript
// 是成功状态 Promise 的一种简写形式

new Promise(resolve => resolve('foo'));

// 简写

Promise.resolve('foo');
```



```JavaScript
// 参数

// 一般参数

Promise.resolve('foo').then(data => {
	console.log(data);
});

```

  

```JavaScript
// Promise当做参数

// 当 Promise.resolve() 接收的是 Promise 对象时，直接返回这个 Promise 对象，什么都不做

const p1 = new Promise(resolve => {
	setTimeout(resolve, 1000, '我执行了');
	
    //相当于
	setTimeout(() => {
		resolve('我执行了');
	}, 1000);

});

Promise.resolve(p1).then(data => {
	console.log(data);
});
//执行结果为 一秒后出现 我执行了

// 等价于 什么都没做 直接返回p1

p1.then(data => {
	console.log(data);
});

console.log(Promise.resolve(p1) === p1); //true


// 当 resolve 函数接收的是 Promise 对象时，后面的 then 会根据传递的 Promise 对象的状态变化决定执行哪一个回调

new Promise(resolve => resolve(p1)).then(data => { //then属于p1 而不管new Promise的状态 
	console.log(data);
});//执行结果为 1秒后出现 我执行了

```

   

```JavaScript
// 具有 then 方法的对象

const thenable = {
	then() {
		console.log('then');
	}
};

// 含有then的方法会被当成是一个Promise对象来对待

//then方法中的then如果没有具体状态操作，Promise.resovle(then方法)会返回一个Promise对象， 状态是pending

//thenable传进之后会直接调用thenable里的then方法， 但这里的.then()不会被执行
Promise.resolve(thenable).then( 
	data => console.log(data),
	err => console.log(err)
);// 执行结果为 then

console.log(Promise.resolve(thenable)); //状态是pending

//如果有具体操作 .then会被执行
const thenable = {
	then(resolve, reject) {
		console.log('then');
		resolve('data');
		//reject('reason');
	}
};

Promise.resolve(thenable).then(
	data => console.log(data),
	err => console.log(err)
);//执行结果为 then data


//有关以上内容的理解， 相当于一个function的参数是object，在调用function时，传进去实际参数
function func(obj) {
	obj.then(1, 2);
}

func({
	then(resolve, reject) {
		console.log(resolve, reject);
	}
});

```



2. Promise.reject()

```JavaScript
// 失败状态 Promise 的一种简写形式

new Promise((resolve, reject) => {
	reject('reason');
});

// 等价于

Promise.reject('reason');

```

   

```JavaScript
// 参数

// 不管什么参数，都会原封不动地向后传递，作为后续方法的参数

const p1 = new Promise(resolve => {
	setTimeout(resolve, 1000, '我执行了');
});

Promise.reject(p1).catch(err => console.log(err)); //(立刻执行) Promise {<pending>}

//Example 成功状态用Promise.resovle()来return意义不大
new Promise((resolve, rejcet) => {
	resolve(123);
})
.then(data => {
	return data;
    //相当于
	//return Promise.resolve(data); (成功状态的Promise)
})
.then(data => {
	console.log(data);
}) //123

//Example 失败状态变的更容易传递 不需要再new一个Promise
new Promise((resolve, rejcet) => {
	resolve(123);
})
.then(data => {
	return Promise.reject('reason');
})
.then(data => {
	console.log(data);
})
.catch(err => console.log(err)); // reason
```



#### Promise.all()

1. 有什么用

```JavaScript
// Promise.all() 关注多个 Promise 对象的状态变化

// 传入多个 Promise 实例，包装成一个新的 Promise 实例返回
```

 

2. 基本用法

```JavaScript
const delay = ms => {
	return new Promise(resolve => {
		setTimeout(resolve, ms); //ms毫秒之后，状态变为成功
	});
};

const p1 = delay(1000).then(() => {
	console.log('p1 完成了');
	return 'p1';
    //return Promise.reject('reason');
});

const p2 = delay(2000).then(() => {
	console.log('p2 完成了');
	return 'p2';
	//return Promise.reject('reason');
});
//执行结果 p1 完成了 p2 完成了
```

   

```JavaScript
// Promise.all() 的状态变化与所有传入的 Promise 实例对象状态有关

// 所有状态都变成 resolved，最终的状态才会变成 resolved

// 只要有一个变成 rejected，最终的状态就变成 rejected


const p = Promise.all([p1, p2]); //参数如果是空数组，p的状态为成功

p.then( //返回的是数组
	data => {
		console.log(data); 
	},
	err => {
		console.log(err);
	}
);

//执行结果 
//p1 完成了
//p2 完成了
//["p1", "p2"]

//在一个参数失败后，Promise.all的then会立刻执行失败回调
const p1 = delay(1000).then(() => {
	console.log('p1 完成了');
    return Promise.reject('reason');
});

const p2 = delay(2000).then(() => {
	console.log('p2 完成了');
	return 'p2';

});
const p = Promise.all([p1, p2]);

p.then(
	data => {
		console.log(data); 
	},
	err => {
		console.log(err);
	}
);
//执行结果 
//p1 完成了
//reason
//p2 完成了

```



#### Promise.race() 和Promise.allSettled()

```JavaScript
const delay = ms => {
	
    return new Promise(resolve => {
		setTimeout(resolve, ms);
	});
};

const p1 = delay(1000).then(() => {
	console.log('p1 完成了');
	return 'p1';
	//return Promise.reject('reason');
});

const p2 = delay(2000).then(() => {
	console.log('p2 完成了');
	//return 'p2';
	return Promise.reject('reason');
});

```



1. Promise.race()

```JavaScript
// Promise.race() 的状态取决于第一个完成的 Promise 实例对象，如果第一个完成的成功了，那最终的就成功；如果第一个完成的失败了，那最终的就失败

const racePromise = Promise.race([p1, p2]);

racePromise.then(
	data => {
		console.log(data);
	},
	err => {
        console.log(err);
    }
);
//执行结果
//p1 完成了
//p1
//p2 完成了
```



2. Promise.allSettled()

```JavaScript
// Promise.allSettled() 的状态与传入的Promise 状态无关

// 永远都是成功的 永远不会执行第二个回调

// 它只会忠实的记录下各个 Promise 的表现 （status）

const allSettledPromise = Promise.allSettled([p1, p2]);

allSettledPromise.then(data => {
    console.log('succ', data);
});

```



#### Promise.any()

1. 语法

   ```JavaScript
   Promise.any(iterable);
   ```

2. 参数
   - iterable：表示一个可迭代的对象，例如：数组

3. 常见返回值

   传入的参数是一组Promise实例。只有当所有Promise实例都编程rejected状态时，返回的Promise才会成为rejected状态，参数中只要有一个Promise是成功状态，则返回的Promise状态是成功。

   

   示例：

   ```JavaScript
   // 失败
   const p1 = new Promise((resolve, reject) => {
       reject()
   });
   // 失败
   const p2 = new Promise((resolve, reject) => {
       reject()
   });
   // 成功
   const p3 = new Promise(resolve => {
       resolve()
   });
   const res = Promise.any([p1, p3, p2])
   console.log(res) // 返回成功状态的Promise
   
   //传入的一组Promise实例参数中，虽然p1、p2这两个是失败状态，但其中的p3是成功状态，所以Promise.any()最终返回结果是成功状态的Promise
   ```

   示例2：

   ```JavaScript
   // 失败
   const p1 = new Promise((resolve, reject) => {
       reject()
   });
   // 失败
   const p2 = new Promise((resolve, reject) => {
       reject()
   });
   // 失败
   const p3 = new Promise((resolve, reject) => {
       reject()
   });
   const res = Promise.any([p1, p3, p2])
   console.log(res) // 返回失败状态的Promise
   
   //由于参数中的p1、p2、p3这三个Promise实例都是失败状态，所以Promise.any()返回一个失败状态的Promise实例
   ```

   

4. 注意事项

   Promise.any() 不会因为某个Promise实例变为失败状态而结束，这个方法用于返回第一个成功的Promise。只要有一个Promise成功此方法就会终止，它不会等待其他的Promise全部完成

```JavaScript
const p1 = new Promise((resolve, reject) => {
    reject("失败");
});

const p2 = new Promise((resolve, reject) => {
    setTimeout(resolve, 500, "最后完成");
});

const p3 = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, "第一个完成");
});

const res = Promise.any([p1, p2, p3])
res.then((value) => {
    console.log(value);
})
//返回结果
//第一个完成

//上面这段代码中，p1是失败状态，Promise.any()不会在这里结束，当p3成功后，Promise.any终止，并不会执行p2的最后完成
```



5. 与Promise.any() 和 Promise.race()的区别

   - Promise.any() 会返回一组完成值，而Promise.any()只能得到最多一个成功值。当我们只需要一个promise成功，而不关心是哪一个成功时，此方法快捷有效 

   - Promise.race() 总是返回第一个结果，而Promise.any() 返回第一个成功的结果。any会忽略掉所有失败的promise，直到遇到第一个成功

     

6. 实际应用场景

   实际开发中，可能会有这样的需求： 一次性加载多张图片，哪一张先加载出来就显示哪一张。那么此时就可以使用Promise.any()方法实现效果

   

### Promise的注意事项和应用

#### 注意事项

1. resolve 或 reject 函数执行后的代码

```javascript
// 推荐在调用 resolve 或 reject 函数的时候加上 return，不再执行它们后面的代码

new Promise((resolve, reject) => {
	// return resolve(123);
	return reject('reason');
	console.log('hi'); //没有return 就会被执行，这里有return，不会被执行
});

```

 

2. Promise.all/race/allSettled 的参数问题

```javascript
// 参数如果不是 Promise 数组，会将不是 Promise 的数组元素转变成 Promise 对象

Promise.all([1, 2, 3]).then(datas => {
	console.log(datas);
});

// 等价于

Promise.all([
	Promise.resolve(1),
	Promise.resolve(2),
	Promise.resolve(3)
]).then(datas => {
	console.log(datas);
}); //执行结果 [1, 2, 3]


// 不只是数组，任何可遍历的都可以作为参数
// 数组、字符串、Set、Map、NodeList、arguments

Promise.all(new Set([1, 2, 3])).then(datas => {
	console.log(datas);
});
//执行结果 [1, 2, 3]
```

 

3. Promise.all/race/allSettled 的错误处理

```javascript
const delay = ms => {
	return new Promise(resolve => {
		setTimeout(resolve, ms);
	});
};

//单独处理rejected
const p1 = delay(1000).then(() => {
	console.log('p1 完成了');
	return Promise.reject('reason');
});
.catch(err => {
	console.log('p1', err);
});

const p2 = delay(2000).then(() => {
	console.log('p2 完成了');
	return 'p2';
});
.catch(err => {
	console.log('p2', err);
});


const allPromise = Promise.all([p1, p2]);

allPromise.then(datas => {
	console.log(datas);
})
//执行结果
//p1 完成了
//p1 reason
//p2 完成了
//(2)[undefined, "p2"]


// 错误既可以单独处理，也可以统一处理
// 一旦被处理，就不会在其他地方再处理一遍

//集中处理rejected
const p1 = delay(1000).then(() => {
	console.log('p1 完成了');
	return Promise.reject('reason');
});

const p2 = delay(2000).then(() => {
	console.log('p2 完成了');
	return 'p2';
});

const allPromise = Promise.all([p1, p2]);

allPromise.then(datas => {
	console.log(datas);
})
.catch(err => console.log(err));
```



#### 应用

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Promise 的应用</title>
    <style>
      #img {
        width: 80%;
        padding: 10%;
      }
    </style>
  </head>
  <body>
    <img
      src="https://img.mukewang.com/5e6af63d00011da318720764.jpg"
      alt=""
      id="img"
    />

    <script>
      // 异步加载图片
      const loadImgAsync = url => {
        return new Promise((resolve, reject) => {
          const img = new Image(); //Image构造函数

          img.onload = () => { //image加载成功
            resolve(img);
          };

          img.onerror = () => { //iamge加载失败
            reject(new Error(`Could not load image at ${url}`));
          };

          img.src = url; //img.src赋值之后，会立刻从url开始请求
        });
      };

      const imgDOM = document.getElementById('img');
      loadImgAsync('https://2img.mukewang.com/5f057a6a0001f4f918720764.jpg')
        .then(img => {
          console.log(img); //<img scr="http..."> 类似dom元素，但没放到dom时是不会显示出来的 这里的img是Promise里的 const img
          console.log(img.src); 
          setTimeout(() => {
            imgDOM.src = img.src; //切换图片
          }, 1000);
        })
        .catch(err => {
          console.log(err);
        });
    </script>
  </body>
</html>
```



### async / await



1. 什么是async / await

   - async / await 是基于Promise实现的
   - async / await 使得异步代码开起来像同步代码
   - 以前的方法有`回调函数`和`Promise`， async / await 是写异步代码的新方式

   

2. async / await语法

   async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。

   示例：

   ```JavaScript
   const timeout= time => {
       return new Promise(function (resolve, reject) {
           setTimeout(function () {
               resolve();
           }, time);
       })
   };
   const start = async () => {
       // 在这里使用起来就像同步代码那样直观
       console.log('start');
       await timeout(3000);
       console.log('end');
       return "imooc"
   };
   start().then(()=> {
       console.log('test....')
   });
   
   //测试结果
   //start
   //(3s later)
   //end
   //test....
   ```

   

3. 注意事项

   (1) await命令只能用在async函数之中，如果用在普通函数，就会报错。

   ```JavaScript
   const timeout = time => {
       return new Promise(function (resolve, reject) {
           setTimeout(function () {
               resolve();
           }, time);
       })
   };
   function fn() {
       await timeout(300)
   }
   fn()
   //报错：Uncaught SyntaxError
   ```

   将fn改为async函数则可正常执行

   ```JavaScript
   const timeout = time => {
       return new Promise(function (resolve, reject) {
           setTimeout(function () {
               resolve();
           }, time);
       })
   };
   async function fn() {
       await timeout(300)
   }
   fn()
   ```

   

   （2）若await后面跟着是一个Promise对象，会等待Promise返回结果了，再继续执行后面的代码。

   ```JavaScript
   const timeout = time => {
       return new Promise(function (resolve, reject) {
           setTimeout(function () {
               console.log('imooc')
               resolve();
   
           }, time);
       })
   };
   const start = async () => {
       await timeout(3000);
       console.log('end');
   };
   start()
   
   //结果
   //(3s later)
   //imooc
   //end
   ```

   

   (3) 若await后面跟着的是一个数值或者字符串等数据类型的值，则直接返回该值

   ```JavaScript
   const num = 1
   const str = "imooc"
   const arr = [1,2]
   const start = async () => {
       console.log(await num)
        console.log(await str)
        console.log(await arr)
   };
   start()
   
   //结果
   //1
   //imooc
   //(2) [1, 2]
   ```

   

   (4) 若await后面跟着的是定时器，不会等待定时器里面的代码执行完，而是直接执行后面的代码，然后再执行定时器中的代码

   ```JavaScript
   const start = async () => {
       console.log(1)
       await setTimeout(() => {
           console.log(2)
       }, 1000);
       console.log(3);
   };
   start()
   
   //结果
   //1
   //3
   //(1s later)
   //2
   ```

   

4. 错误捕获

   可以直接用标准的try catch语法捕捉错误

   ```JavaScript
   const timeout = time => {
       return new Promise(function (resolve, reject) {
           setTimeout(function () {
              // 模拟出错了，返回 ‘error’
               reject('error');
           }, time);
       })
   };
   const start = async () =>{
      try {
           console.log('start');
           await timeout(3000); // 这里得到了一个返回错误
   
           // 所以以下代码不会被执行了
           console.log('end');
       } catch (err) {
           console.log(err); // 这里捕捉到错误 `error`
       }
   };
   start()
   
   //start
   //await等待调用timeout方法返回的Promise对象返回了一个错误，后面的代码不会再执行，直接进入catch，捕捉到错误
   //error
   ```

   



------

## Class 类



### Class基本认识



1. 认识 Class

- 具体的人：实例、对象
- 类可以看做是对象的模板，用一个类可以创建出许多不同的对象



2. Class 的基本用法

```JavaScript
// 类名一般大写

class Person {} √

class Person() {} ×

class Person {}; ×

function func() {}
```



```JavaScript
class Person {

   // 实例化时执行构造方法，所以必须有构造方法，但可以不写出来

	constructor(name, age) {

		console.log('实例化时执行构造方法');
        //this 代表实例对象，上面定义的是实例属性/方法
        
        this.name = name;
        this.age = age;
        
        // 一般在构造方法中定义属性，方法不在构造方法中定义
        //this.speak = () => {};
    }
	
    speak:function(){}

   
// 各实例共享的方法

   speak() {
       console.log('speak');
   }

}

// Person(); （报错，需要通过new来实例化）

const zs = new Person('ZS', 18);

const ls = new Person('LS', 28);

console.log(zs.name);

console.log(zs.age);

console.log(zs.speak);

zs.speak();

console.log(ls.name);

console.log(ls.age);

console.log(ls.speak);

console.log(zs.speak === ls.speak); //在constructor中创立方法，这里就是false，构造方法外声明的方法，这里则是true
```



3. Class 与构造函数

```JavaScript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        // this.speak = () => {};
	}

	speak() {
    	console.log('speak');
	}
    // run(){}
}

//ES6里 Class的本质还是function，在原型上添加方法和在Class内添加是一样的，但是实际应用中，没有人会这么写
Person.prototype.run = function () {};
console.log(typeof Person);
console.log(Person.prototype.speak);

//构造函数(有Class之后，构造函数基本就用不上了)
function Person(name, age) {
    this.name = name;
    this.age = age;
   //this.speak = () => {};
}

Person.prototype.speak = function () {};
```



#### Class的两种定义形式

1. 声明形式

```JavaScript
class Person {
    constructor() {}
    speak() {}
}
```



2. 表达式形式

```JavaScript
//构造函数的表达式形式
function Person(){}
const Person = function () {};

//class的表达式形式
const Person = class {
    constructor() {
        console.log('constructor');
    }
    speak() {}
};

new Person(); //constructor

//立即执行的匿名函数
(function () {
    console.log('func');
})();


// 立即执行的匿名类
new (class {
    constructor() {
        console.log('constructor');
    }
})(); //constructor

```



### Class 属性和方法

#### 实例属性、静态方法和静态属性

1. 实例属性

```JavaScript
// 方法就是值为函数的特殊属性

class Person {
    age = 0;
	sex = 'male';
	getSex = function () {
        return this.sex;
    };

	constructor(name, sex) {
        this.name = name;
        this.age = 18;
        this.sex = sex;
    }
	speak() {
        this.age = 18;
    }
}

const p = new Person('Alex');

console.log(p.name);

console.log(p.age);
```



2. 静态方法

```javascript
// 类的方法

class Person {
    constructor(name) {
        this.name = name;
	}

	speak() {
    	console.log('speak');
    	console.log(this); //指向实例化对象
	}

	static speak() {
    	console.log('人类可以说话');
    	console.log(this); // this 指向类
	}
}

//static 函数相当于
Person.speak = function() {
    console.log('人类可以说话');
    console.log(this); // this 指向类
}

Person.speak = function () {
    console.log('人类可以说话');
    console.log(this);
};

const p = new Person('Alex');

//实例方法
p.speak();  //speak

//类的方法
Person.speak();  //人类可以说话

```



3. 静态属性

```JavaScript
// 类的属性

class Person {
    constructor(name) {
        this.name = name;
    }

// 不要这么写，目前只是提案，有兼容性问题
// static version = '1.0';

	static getVersion() {
    	return '1.0';
	}
}

// Person.version = '1.0';

const p = new Person('Alex');
console.log(p.name);

//console.log(Person.version);
console.log(Person.getVersion());
```



**小练习**

以下代码中，有几处会报错？

```JavaScript
class Person {
    run(){
        console.log('run')
    }
    static eat() {
        console.log('eat')
    }
    static age = 18
}
console.log(Person.age)
const p = new Person()
console.log(p.age)
p.eat()
Person.run()

//本题主要考查class的实例属性和静态属性。

//实例属性只能通过实例对象访问，静态属性只能通过类本身访问。

//本题代码中run是实例方法，而Person是类，类不可以访问实例方法，会出现报错，所以Person.run()是一处错误。

//eat方法是静态方法，而p是实例对象，实例对象无法访问静态方法，会出现报错，所以p.eat()是一处错误。

//age是静态属性，可以在实例化对象之前通过类本身访问，所以console.log(Person.age)这代码可以正常输出结果。

//
 
    实例对象不可以访问静态属性，但是p.age相当于访问对象上一个不存在的属性，默认返回undefined，并不会报错，不能算作一个错误。
```



#### 私有属性和方法

1. 为什么需要私有属性和方法

```javascript
// 一般情况下，类的属性和方法都是公开的

// 公有的属性和方法可以被外界修改，造成意想不到的错误

class Person {
    constructor(name) {
        this.name = name;
}

	speak() {
    	console.log('speak');
	}

	getName() {
    	return this.name;
	}
}

const p = new Person('Alex');
console.log(p.name); //Alex
p.speak();


// ....

p.name = 'zs'; //属性可以被任意修改
console.log(p.name); //zs
```



2. 模拟私有属性和方法

     2.1. **_** 开头表示私有 （不具备约束力，是约定俗成的风格）

```JavaScript
class Person {
    constructor(name) {
        this._name = name; //私有
    }
	speak() {
        console.log('speak');
    }
	
    getName() {
        return this._name;
    }
}

const p = new Person('Alex');

console.log(p.name); //undefined
console.log(p.getName());// Alex

p.name = 'zd';
```



2.2. 将私有属性和方法移出类

```JavaScript
//杜绝外部访问的可能性 一般不太会这么用 除非一定要私有
(function () {
    let name = '';
    class Person {
        constructor(username) {
            // this.name = name;
            name = username;
        }
        speak() {
            console.log('speak');
        }
        getName() {
            return name;
        }
    }
    window.Person = Person; //class添加到全局中，就可以访问到class
})();

(function () {
    const p = new Person('Alex');
    console.log(p.name); //undefined
    console.log(p.getName()); //Alex
})();
```



### Class的继承

#### extends

1. 子类继承父类

```JavaScript
class Person {
    constructor(name, sex) {
        this.name = name;
        this.sex = sex;
        this.say = function () {
            console.log('say');
        };
    }
    speak() {
        console.log('speak');
    }
    
    static speak() {
        console.log('static speak');
    }
}

Person.version = '1.0';

class Programmer extends Person {
    constructor(name, sex) {
        super(name, sex); //如果super里没有参数，这name和sex都不会被记录，默认undefined
    }
}

const zs = new Programmer('zs', '男');
console.log(zs.name); // zs
console.log(zs.sex); // 男

zs.say(); //say
zs.speak();//speak

Programmer.speak(); //static speak

console.log(Programmer.version); //1.0
```



2. 改写继承的属性或方法

```JavaScript
class Programmer extends Person {
    constructor(name, sex, feature) {
        // this.feature = feature; ×
        // this 操作不能放在 super 前面
        super(name, sex);
        this.feature = feature;
    }
    
    hi() {
        console.log('hi');
    }
    
    // 同名覆盖 以子类为准
    
    speak() {
        console.log('Programmer speak');
    }
    
    static speak() {
        console.log('Programmer static speak');
    }
}

Programmer.version = '2.0';

const zs = new Programmer('zs', '男', '秃头');
console.log(zs.name); //zs
console.log(zs.sex); //男
console.log(zs.feature); //秃头

zs.say(); //say
zs.speak(); //Programmer static speak
zs.hi(); //hi
Programmer.speak(); //Programmer static speak

console.log(Programmer.version); //2.0
```



#### super

1. 作为函数调用

```JavaScript
// 代表父类的构造方法，只能用在子类的构造方法中，用在其他地方就会报错

// super 虽然代表了父类的构造方法，但是内部的 this 指向子类的实例

class Person {
	constructor(name) {
		this.name = name;
        console.log(this);
    }
}

class Programmer extends Person {
    constructor(name, sex) {
        super(name, sex);
    }
    
    hi() {
        //super(); // ×
    }
}

new Person();

new Programmer();

```

   

2. 作为对象使用

     2.1.在构造方法中使用或一般方法中使用

   ```javascript
   // super 代表父类的原型对象 Person.prototype
   // 所以定义在父类实例上的方法或属性，是无法通过 super 调用的
   
   // 通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例
   
   class Person {
       constructor(name) {
           this.name = name;
           console.log(this);
       }
       
       speak() {
           console.log('speak');
           console.log(this);
       }
       
       static speak() {
           console.log('Person speak');
           console.log(this);
       }
   }
   
   class Programmer extends Person {
       constructor(name, sex) {
           super(name, sex);
           console.log(super.name);
           super.speak();
       }
       hi() {
           //super(); // ×
       }
       speak() {
           super.speak();
           console.log('Programmer speak');
       }
       
        //2.2.在静态方法中使用
       
       // 指向父类，而不是父类的原型对象
   	// 通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例
   
   	static speak() {
       	super.speak();//在这里调用的话，constructor里面就不要调用super.speak了
       	console.log('Programmer speak');
   	}
   }
   
   new Person();
   new Programmer();
   Programmer.speak();
   ```

   

3. 注意事项

```javascript
// 使用 super 的时候，必须显式指定是作为函数还是作为对象使用，否则会报错

class Person {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log('speak');
    }
}

class Programmer extends Person {
    constructor(name, sex) {
        super(name, sex);
        console.log(super); //报错
        console.log(super()); //
        console.log(super.speak); //
    }
}
```

- super作为函数调用时，代表父类的构造函数
- super中的this指向的是子类的this
- 非静态方法中，指向父类的原型对象
- 在静态方法中，指向父类



**小练习**

```JavaScript
//super关键字作为对象使用时，在子类实例方法中，指向父类的原型对象；在子类静态方法中，指向父类。

class Parent {
    color = "red"
	constructor(username) {
        this.username = username
    }
	static pSay() {
        console.log(this.username)
    }
	pShow() {
        console.log(this.color)
    }
}
class Child extends Parent {
    constructor(username) {
        super(username)
    }
    static cSay() {
        super.pSay()
    }
    cShow() {
        super.pShow()
        console.log(super.color)
    }
}
const c1 = new Child('c1')
Child.cSay() //undefined
c1.cShow() //red undefined


//本题代码中Child类继承了Parent类，具体的解析参考如下：

//1、子类静态方法cSay中，super作为对象时，指向父类Parent。
//调用父类的方法pSay时，该方法内部的this指向子类Child, 无法访问到实例属性username，结果为undefined。

//2、子类实例方法cShow中super作为对象使用，指向父类原型,即：Parent.prototype，
//调用父类的方法pShow时，该方法内部的this指向子类实例对象，可以访问实例对象上的color属性，结果为red。

//3、super.color这句代码相当于访问父类原型上的color属性，不可以访问实例属性color，由于父类原型上并没有color属性，所以结果为undefined。

//代码最终的输出结果为undefined red undefined

```



------



## Module 模块

### 基本认识

   // 1.什么是模块

   // 模块：一个一个的局部作用域的代码块



   // 2.什么是模块系统

   // 模块系统需要解决的主要问题

   // ① 模块化的问题

   // ② 消除全局变量

   // ③ 管理加载顺序



   // RequireJS seaJS （第三方模块库，已经是过去式）



   // ES Module （ES6的官方模块）



#### 基本用法

1. 使用 Module 模块化之前的例子



2. 使用 script 标签加载模块

   // console.log(Slider);



   // 一个文件就是一个模块

   // **只要你会用到 import 或 export，在使用 script 标签加载的时候，就要加上`type="module"`**



3. 分析 Module 解决的问题

   ① 模块化的问题

   ② 消除全局变量

   ③ 管理加载顺序



### Module的导入和导出

1. 认识导出和导入

   - 导出的东西可以被导入（import），并访问到
   - 一个模块没有导出，也可以将其导入
   -  **被导入的代码都会执行一遍，也仅会执行一遍**

```JavaScript
import './module.js';
import './module.js';
import './module.js';
//多次导入也只会执行一次
```

2. 基本用法

   ```JavaScript
   //export default用法
   //**一个模块只能有一个 export default**
   
   //module.js文件中
   const age = 18
   export default age;
   
   //html文件中
   //可以随便起名
   
   //import aaa from './module.js';
   import age from './module.js';
   console.log(age);
   
   //export default 可以导出多种类型
   export default age;
   export default 20;
   export default {};
   
   const fn = () =>{};
   export default fn;
   export default function(){};
   export default class{};
   //无需给函数等起名是因为外面导入时可以自己命名，用不到这里的命名
   ```



#### export 和 对应的 import

1. 基本用法

```JavaScript
// export 声明或语句
// export const age = 18; 但一般不这样export，而是使用下面的语法

const age = 18;
export { age };


// 不能随意命名
import { age } from './module.js';
console.log(age);

//export可导出内容

function fn(){}
export fn; //报错

export function fn(){}
export function (){} //报错 匿名不行

class className {}
export className; //可以

export class className {}
export class {} //报错 匿名不行
```



2. 多个导出导入

```javascript
//可以导出多个内容
export {fn, className, age};

//可以分开导入，也可以统一导入
import { fn } from './module.js';
console.log(fn);

import { className } from './module.js';
console.log(className);


import { fn, age, className } from './module.js';
console.log(fn, age, className);
```



3. 导出导入时起别名

```javascript
export { fn as func, className, age };

import { func, age, className as Person } from './module.js';

console.log(Person);
```



4. 整体导入

```javascript
// 会导入所有输出，包括通过 export default 导出的

import { func, age, className } from './module.js';
console.log(func, age, className);


import obj from './module.js';
import * as obj from './module.js';

console.log(obj);
```



5. 同时导入

```JavaScript
// export default 可以和export同时使用

import { func, age, className } from './module.js';
import age2 from './module.js';


// 一定是 export default 的在前

import age2, { func, age, className } from './module.js';
import { func, age, className },age2 from './module.js'; ×
```



### 注意事项和应用

#### 注意事项

```html
 <body>

  <!-- <script src="./module.js"></script> -->
  <!-- <script src="./module.js" type="module"></script> -->

    <script type="module">
        ...
  </script>
 </body>
```



1. 模块顶层的 this 指向

   ```JavaScript
   //module.js
   console.log(this);
   
   //非模块加载方式，this指向Window
   // 模块中，顶层的 this 指向 undefined
   import './module.js';
   
   //执行结果 undefined
   ```
   
   

2. import 和 import()

```JavaScript
// import 命令具有提升效果，会提升到整个模块的头部，率先执行

console.log('沙发');
console.log('第二');

import './module.js';
//执行结果
//undefined
//沙发
//第二


// import 执行的时候，代码还没执行
// import 和 export 命令只能在模块的顶层，不能在代码块中执行

if (PC) {
    import 'pc.js';
} else if (Mobile) {
    import 'mobile.js';
}
//以上pseudo code 是错误写法，无法执行

// 想要完成以上需求，使用import()
//import() 可以按条件导入，返回promise对象

if (PC) {
    import('pc.js').then().catch();
} 
else
    import('mobile.js').then().catch();
}

//注意：import()现在只是提案，还不是标准，有不兼容的风险
```



3. 导入导出的复合写法

```JavaScript
// 复合写法导出的，无法在当前模块中使用
//导入导出的复合写法，在导入的同时将其导出出去，相当于中转站，在当前模块是无法访问导入的变量

export { age } from './module.js';
console.log(age); //报错

// 等价于，但是下面的写法，是可以访问到导入的内容的

//导入文件
import { age } from './module.js';

//模块文件
export { age } from './module.js';
console.log(age); // 18
```



------

## Babel和Webpack



### Babel

#### 什么是Babel

1. 认识 Babel

- 官网：https://babeljs.io/

- 在线编译：https://babeljs.io/repl



   Babel 是 JavaScript 的编译器，用来将 ES6 的代码，转换成 ES6 之前的代码



2. 使用 Babel

```JavaScript
//在Babel官网的 Try it out 中，可以简单的编译JS代码

// ES6版本

let name = 'Alex';
const age = 18;

const add = (x, y) => x + y;


// Set Map

new Promise((resolve, reject) => {
    resolve('成功');
}).then(value => {
    console.log(value);
});

Array.from([1, 2]);

class Person {
    constructor(name, age) {
        Object.assign(this, { name, age });
    }
}

new Person('Alex', 18);

import './index.js';
```



```JavaScript

// 使用 Babel 编译后 (勾选es2015)

('use strict'); //模块中默认strict模式

require('./index.js'); //import的编译，这里需要结合Webpack才能实现import功能

function _instanceof(left, right) {
    if (
        right != null &&
        typeof Symbol !== 'undefined' &&
        right[Symbol.hasInstance]
    ) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}

var name = 'Alex';
var age = 18;

var add = function add(x, y) {
    return x + y;
};

new Promise(function (resolve, reject) {
    resolve('成功');
}).then(function (value) {
    console.log(value);
});

Array.from([1, 2]);

var Person = function Person(name, age) {
    _classCallCheck(this, Person);
    Object.assign(this, {
        name: name,
        age: age
    });
};

new Person('Alex', 18);
```



3. 解释编译结果

- Babel 本身可以编译 ES6 的大部分语法，比如 let、const、箭头函数、类

- 但是对于 ES6 新增的 API，比如 Set、Map、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign/Array.from）都不能直接编译，需要借助其它的模块

- Babel 一般需要配合 Webpack 来编译模块语法



#### 使用Babel前的准备工作



官网Setup里可以查看使用方法，常用是CLI（命令行工具）是Webpack



文档：

```
├─- package-lock.json
└─- package.json
```

1. 什么是 Node.js 和 npm

- Node.js 是个平台或者工具，对应浏览器

- 相当于后端的 JavaScript = ECMAScript + IO + File + ...等服务器端的操作



-  `npm：node` 包管理工具

  ```shell
  $ npm install
  ```

  

2. 安装 Node.js

   ```shell
   $ node -v
   $ npm -v
   ```

   

3. 初始化项目

   ```shell
   $ npm init 
   
   # 生成package.json，记录安装过的npm文件
   ```

   

4. 安装 Babel 需要的包

   ```shell
   $ npm install --save-dev @babel/core @babel/cli
   #开发依赖，上线后不需要
   
   $ npm install --save-dev @babel/core@7.11.0 @babel/cli@7.10.5
   #可以选择安装指定版本号
   
   $ npm install
   #在package.json复制过来的情况下，直接通过以上命令可以安装package.json中的包
   ```

   

#### 使用Babel编译ES6代码

```
├─- dist
|   └── babel.js
├─- src
|   └── babel.js
├─- package-lock.json
└─- package.json
```

1. 首先安装 包

   ```shell
   $ npm install
   ```

   

2. 在官网 **Setup-->CLI--> Usage** 中复制（"scripts: {}"）以下代码到package.json中

   ```json
   +   "scripts": {
   +     "build": "babel src -d lib"
   +   },
   
   //package.json文件示例
     {
       "name": "my-project",
       "version": "1.0.0",
   +   "scripts": {
   +     "build": "babel src -d lib" 
         //-d 是 --out-dir 的缩写，代表输出目录，前面的src是源目录，后面的lib是可修改的输出文件夹名
   +   },
       "devDependencies": {
         "@babel/cli": "^7.0.0"
       }
     }
   
   ```

   

3. 编辑配置文件

   ```shell
   $ npm install @babel/preset-env --save-dev 
   #最新版
   
   $ npm install @babel/preset-env@7.11.0 --save-dev
   #指定版本号
   ```

   `.babelrc` file:

   ```json
   {
       "presets": ["@babel/preset-env"]
   }
   ```




4. 执行build命令

```shell
$ npm run build

#之前src文件夹中的所有js文件会被编译，编译好的文件在lib中
```



### Webpack

### 基本认识

Vue，React之类的框架底层也是基于Webpack。

 https://webpackjs.com 



1. 认识 Webpack

- webpack 是**静态模块打包器**，当 webpack 处理应用程序时，会将所有这些模块打包成一个或多个文件

```JavaScript
import './module.js'
require('./module.js')
```

 

2. 什么是 Webpack

- 模块
  - webpack 可以处理 js/css/图片、图标字体等单位



- 静态

  - 开发过程中存在于本地的 js/css/图片/图标字体等文件，就是静态的

    ```html
    <!--静态-->
    <img src="./img/logo.png" alt="" />
    
    <!--动态-->
    <img src="https://www.imooc.com/static/img/index/logo.png" alt="" />
    ```

  - 动态的内容，webpack没办法处理，只能处理静态的

------



### 使用流程



1. 初始化流程

```shell
$ npm init
package name: <name> #必须是英文名称
version: <(1.0.0)> #默认值即可
... #一路回车

Is this OK? (yes)
#生成package.json
```



2. 安装webpack需要的包

   ```shell
   $ npm install --save-dev webpack-cli@3.3.12 webpack@4.44.1
   ```

   

3. 配置 webpack

   ```
   ├─- src
   	├── index.js
   	└── module.js
   ├─- index.html 
   ├─- webpack.config.js
   ├─- package.json
   └─- package-lock.json
   ```

   

   `webpack.config.js`

   ```json
   //使用的是Node.js的模块方法，而不是ES6
   
   const path = require('path');
   
   //需要导出的内容写在module.exports中
   //以下是官网中提供的例子
   module.exports = {
     mode: 'development', //指定开发模式的话，编译出来的代码不会被压缩。这条不写，编译出的代码是挤在一起的
     entry: './src/index.js',
     output: {
       path: path.resolve(__dirname, 'dist'),
       filename: 'bundle.js'
     }
   };
   ```



4. 编译并测试

   `index.js`

   ```javascript
   import age from './module.js';
   console.log('index.js', age);
   ```

   `module.js`

   ```javascript
   export default 18;
   console.log('module.js');
   ```

   `package.json`

   ```json
   {
     "name": "webpack2",
     "version": "1.0.0",
     "description": "",
     "main": "index.js",
     "scripts": {
       "webpack": "webpack --config webpack.config.js" //自行创立的Babel命令，"<命名>"可以自定义
       //"webpack": "webpack" //默认webpack.config.js命名情况下以上两种写法效果一致
     },
     "author": "",
     "license": "ISC",
     "devDependencies": {
       "webpack": "^4.44.1",
       "webpack-cli": "^3.3.12"
     }
   }
   ```

   `执行webpack编译`

   ```shell
   $ npm run webpack
   ```

   目录中多出`dist`文件夹

   ```
   ├─- src
   	├── index.js
   	└── module.js
   ├─- dist
   	└── bundle.js	
   ├─- index.html 
   ├─- webpack.config.js
   ├─- package.json
   └─- package-lock.json
   ```

   ------

   

### 核心概念

#### entry和output

1. entry

- 指定入口文件

- 单入口

  ```json
  const path = require('path');
  
  module.exports = {
    mode: 'development',
    entry: './src/index.js',
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: 'bundle.js'
    }
  };
  ```

  

- 多入口

  ```json
  module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js',
        search: './src/search.js' //"search"这样的命名是自定义的，根据需求来起名
    },
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: '[name].js'
    }
  };
  ```

  

2. output

- 出口配置

  ```json
  const path = require('path');
  
  module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js',
        search: './src/search.js'
    },
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: '[name].js'  //多入口的情况下，需要这样来书写，如果指定一个名字，会使多个入口的出口有冲突
    }
  };
  ```

  

#### loader

1. 什么是 loader

-  webpack js/css/图片
- loader 让 webpack 能够去处理那些非 JS 文件的模块
-  babel



2. babel-loader

   ```shell
   npm install --save-dev babel-loader@8.1.0
   ```

   

3. 安装 Babel

   ```shell
   npm install --save-dev @babel/core@7.11.0 @babel/preset-env@7.11.0
   ```

   

4. 配置 babel-loader

​    https://www.webpackjs.com/loaders/

​	`webpack.config.js`

```json	
const path = require('path');

module.exports = {
  mode: 'development',
  entry: {
    index: './src/index.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [
      {
        test: /\.js$/, //匹配在哪些文件中使用babel文件，此示例中，匹配所有.js文件
        exclude: /node_modules/, //符合上述条件中排除哪个文件夹
        loader: 'babel-loader' //连通babel和webpack，先babel编译再webpack打包
      }
    ]
  }
};
```

到这一步，虽然有一些编译，但是很多ES6特有的语法并没有改变，所以需要接下来的后续工作。



5. 引入 core-js

      编译新增 API

   http://babeljs.io/docs/en/babel-polyfill

   ```shell
   npm install --save-dev core-js@3.6.5
   ```

   

   ```JavaScript
    import "core-js/stable"; //在index.js中
   ```

   

6. 打包并测试

   ```shell
   npm run webpack
   ```

   

#### plugins

1. 什么是 plugins

- 插件

- loader 被用于帮助 webpack 处理各种模块，而插件则可以用于执行范围更广的任务



   https://www.webpackjs.com/plugins/



2. html-webpack-plugin （以此插件为例，该插件可以自动在html中导入js文件）

   ```shell
    npm install --save-dev html-webpack-plugin@4.3.0
   ```

   

3. 配置 html-webpack-plugin 插件

```json
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin'); //引入插件

module.exports = {
  mode: 'development',
  entry: {
    index: './src/index.js',
    search: './src/search.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  plugins: [
    // 单入口
    // new HtmlWebpackPlugin({
    //   template: './index.html'
    // })

    // 多入口
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html', //必须指定命名，否则后面的模板会把前面的覆盖到一个文件
      chunks: ['index'], //引入的文件名（import部分，如果不写，会全部js文件都引入）
      minify: {
        // 删除 index.html 中的注释
        removeComments: true,
        // 删除 index.html 中的空格
        collapseWhitespace: true,
        // 删除各种 html 标签属性值的双引号
        removeAttributeQuotes: true
      }
    }),
    new HtmlWebpackPlugin({
      template: './search.html',
      filename: 'search.html',
      chunks: ['search']
    })
  ]
};
```

------



### 应用

#### 处理CSS文件

```
├─- src
	├── index.js
	└── index.css
├─- index.html 
├─- webpack.config.js
├─- package.json
└─- package-lock.json
```

**在js文件中导入css文件**

```javascript
import './index.css';
```

`package.json`配置

```json
{
  "name": "webpack-css",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "webpack": "webpack"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "css-loader": "^4.1.1",
    "html-webpack-plugin": "^4.3.0",
    "mini-css-extract-plugin": "^0.9.0",
    "style-loader": "^1.2.1",
    "webpack": "^4.44.1",
    "webpack-cli": "^3.3.12"
  }
}
```



**添加css loader**

webpack原生不能识别css文件，需要通过loader来连接

```shell
$ npm install --save-dev css-loader@4.1.1
```

**添加style loader**

光有css-loader只能帮助识别css文件，但是并不会正常引入，所以需要style-loader来引入

```shell
$ npm install --save-dev style-loader@1.2.1
```

**通过link标签引入**

除了style标签引入，也可以通过link标签引入，而且这种方式更常用。这里需要用到`miniCssExtract`插件

```shell
$ npm install --save-dev mini-css-extract-plugin@0.9.0
```



`webpack.config.js`配置

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        // loader: 'css-loader' //单个loader可以这样写，多个loader需要使用use
        // use: ['style-loader', 'css-loader'] //通过style标签引入，注意顺序
        use: [MiniCssExtractPlugin.loader, 'css-loader'] //通过link标签引入
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html'
    }),
    new MiniCssExtractPlugin({
      filename: 'css/[name].css' //整合css输出位置
    })
  ]
};
```



**打包webpack**

```shell
$ npm run webpack
```



#### 使用file-loader处理CSS中的图片

远程图片（外部资源）是不需要考虑webpack的，只有本地的图片才需要被webpack处理。

```
├─- src
	├── img
	    └── logo.png
	├── index.js
	└── index.css
├─- index.html 
├─- webpack.config.js
├─- package.json
└─- package-lock.json
```

本地图片不经过file-loader处理，webpack无法识别。

注意：file-loader并不是单独用来处理图片的，任何文件都可以

```shell
$ npm install --save-dev file-loader@6.0.0
```

`webpack.config.js`配置

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '../' //加了这个之后，图片等引用路径会加上../
            }
          },
          'css-loader'
        ]
      },
      {
        test: /\.(jpg|png|gif)$/,
        use: {
          loader: 'file-loader',
          options: {
            name: 'img/[name].[ext]' //指定命名和输出路径
          }
        }
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html'
    }),
    new MiniCssExtractPlugin({
      filename: 'css/[name].css'
    })
  ]
};
```



#### 使用html-withimg-loader处理HTML中的图片

html标签中引入的本地图片如果不经过loader处理，则无法复制图片文件到打包文件中，也不会被替换正确路径。

```shell
npm install --save-dev html-withimg-loader@0.1.16
```

`webpack.config.js`

**注意file-loader的配置**

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '../'
            }
          },
          'css-loader'
        ]
      },
      {
        test: /\.(jpg|png|gif)$/,
        use: {
          loader: 'file-loader',
          options: {
            name: 'img/[name].[ext]',
            esModule: false //这里不写的话，html文件中的img会被替换成对象形式
          }
        }
      },
      {
        test: /\.(htm|html)$/,
        loader: 'html-withimg-loader'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html'
    }),
    new MiniCssExtractPlugin({
      filename: 'css/[name].css'
    })
  ]
};
```



#### 使用file-loader处理JS中的图片

在js文件中同样可以引入图片

```javascript
import './index.css';
import img from './img/logo.png';

console.log(img);

const imgEl = document.createElement('img');
imgEl.src = img;

document.body.appendChild(imgEl);
```



#### 使用url-loader处理图片

使用url-loader的话，就不用再配置file-loader了，但是url-loader的底层涉及file-loader，所以还是需要安装file-loader

```shell
$ npm install --save-dev url-loader@4.1.0
```

`webpack.config.js`

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '../'
            }
          },
          'css-loader'
        ]
      },
      {
        test: /\.(jpg|png|gif)$/,
        use: {
          loader: 'url-loader',
          options: {
            name: 'img/[name].[ext]',
            esModule: false,
            limit: 10000 //小于10kb的文件会被做base64处理，文件不会再被复制过去
          }
        }
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html'
    }),
    new MiniCssExtractPlugin({
      filename: 'css/[name].css'
    })
  ]
};
```

**注意：小图标等比较小的图片可以做base64处理，稍大的图片不要这么处理，会让js文件变的很大**



#### 使用webpack-dev-server搭建开发环境

使用webpack-dev-server可以帮助每次保存之后自动打包，免除每次手动删除输出文件再次打包的重复劳动。

```shell
$ npm install --save-dev webpack-dev-server@3.11.0
```

`package.json`

```json
{
  "name": "webpack-url-loader",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "webpack": "webpack",
    "dev": "webpack-dev-server --open chrome" //使用一次即可
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "css-loader": "^4.1.1",
    "html-webpack-plugin": "^4.3.0",
    "mini-css-extract-plugin": "^0.9.0",
    "webpack": "^4.44.1",
    "webpack-cli": "^3.3.12",
    "webpack-dev-server": "^3.11.0"
  }
}
```

```shell
$ npm run dev
```

每次项目保存之后，浏览器中可以实时看到变化。输出的内容在内存中，不在项目目录中。



`webpack.config.js` 

使用默认配置可以不用再webpack.config.js文件中做任何修改。

如果需要改变配置，可以参考 https://www.webpackjs.com/configuration/dev-server/

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  // devServer:{},//默认配置，不需要写
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '../'
            }
          },
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html'
    }),
    new MiniCssExtractPlugin({
      filename: 'css/[name].css'
    })
  ]
};
```

------



## 前后端数据交互

### 基本认识

1. 前后端通信是什么

- 前端和后端数据交互的过程

- 可以看作是浏览器和服务器之间数据交互的过程



2. 后端向前端发送数据

- 如访问页面时，网页呈现的就是后端向前端发送数据后，前端加载的结果



3. 前端向后端发送数据

- 如用户注册
- 搜索功能



### 前后端通信的过程与概念

1. 前后端通信的过程

- 前后端的通信是在‘请求-响应’中完成的

<img src="http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/1.前后端通信的过程.png" alt="1.前后端通信的过程" style="zoom:80%;" />

2. 概念解释

- 前端：一般是指浏览器端

- 客户端：只要能和服务器通信的就叫客户端

- 命令行工具

  ```shell
  $ curl https:www.imooc.com
  
  #获取html页面，但因为无法解析，只能看到字符串
  ```

  

- 后端：服务器端



### 前后端的通信方式

1. 使用浏览器访问网页

- 在浏览器地址栏输入网址，按下回车



2. HTML 的标签

- 浏览器在解析 HTML 标签的时候，遇到一些特殊的标签，会再次向服务器发送请求
  - 如`link/img/script/iframe`
- 还有一些标签，浏览器解析的时候，不会向服务器发送请求，但是用户可以使用他们向服务器发送请求
  - 如`a/form`

- chrome浏览器针对**同一个域名**下可以有6个同时的并发请求

  

3. Ajax 和 Fetch

------



## HTTP协议

### 基本认识

1. HTTP 是什么

   - **HyperText Transfer Protocol**

   - 超文本传输协议

   - HTML：超文本标记语言



**超文本：**原先一个个单一的文本，通过超链接将其联系起来。由原先的单一的文本变成了可无限延伸、扩展的超级文本、立体文本

- HTML、JS、CSS、图片、字体、音频、视频等等文件，都是通过 HTTP（超文本传输协议） 在服务器和浏览器之间传输
- 每一次前后端通信，前端需要主动向后端发出请求，后端接收到前端的请求后，可以给出响应
- HTTP 是一个请求-响应协议



2. HTTP 请求响应的过程

   - 浏览器在请求某一个地址时，会先在缓存中查找是否访问过此地址。如果访问过，则不会像服务器发送HTTP请求了。

   

   ![2.HTTPResponsProcess](http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/2.HTTPResponsProcess.png)


#### HTTP报文

```html
<body>
    <!--GET请求-->
    <form action="https://www.imooc.com" method="get">
      <input type="text" name="username" placeholder="用户名" />
      <input type="password" name="password" placeholder="密码" />
      <input type="submit" value="注册" />
    </form>

    <!--POST请求-->
    <form action="https://www.imooc.com" method="post">
      <input type="text" name="username" placeholder="用户名" />
      <input type="password" name="password" placeholder="密码" />
      <input type="submit" value="注册" />
    </form>
</body> 
```



1. HTTP 报文是什么
   - 浏览器向服务器发送请求时，请求本身就是信息，叫请求报文
   - 服务器向浏览器发送响应时传输的信息，叫响应报文



2. HTTP 报文格式

   ![3.httpReport](http://yunabell-image-repository.oss-cn-shanghai.aliyuncs.com/img/3.httpReport.png)

   **请求：**

   - 请求头：起始行+首部
   - 请求体
   - GET 请求，没有请求体，数据通过请求头携带
   - POST 请求，有请求体，数据通过请求体携带

   **响应：**

   - 响应头：起始行+首部
   - 响应体



### HTTP方法

1. 常用的 HTTP 方法
   - 浏览器**发送请求时**采用的方法，和响应无关
   - GET、POST、PUT、DELETE
   - 用来定义对于资源采取什么样的操作的，有各自的语义



2. HTTP 方法的语义



**GET 获取数据**

- 获取资源（文件）



**POST 创建数据**

- 注册



**PUT 更新数据**

- 修改个人信息，修改密码



**DELETE 删除数据**

- 删除一条评论



注意：增删改查，这些方法虽然有各自的语义，但是并不是强制性的



3. RESTful 接口设计

   一种接口设计风格，充分利用 HTTP 方法的语义



**注意以下例子都不是RESTful风格**

 通过用户 ID 获取个人信息，使用 GET 方法

-  如：https://www.imooc.com/api/http/getUser?id=1

注册新用户，使用 POST 方法

-  如：https://www.imooc.com/api/http/addUser

修改一个用户，使用 POST 方法

- 如：https://www.imooc.com/api/http/modifyUser

删除一个用户，使用 POST 方法

- 如：https://www.imooc.com/api/http/deleteUser



**以下是RESTful风格：**

同一个接口，不同的HTTP方法就可以区分目的



**GET**

- 如：https://www.imooc.com/api/http/user?id=1

**POST**

- 如：https://www.imooc.com/api/http/user

**PUT**

- 如：https://www.imooc.com/api/http/user

**DELETE**

- 如：https://www.imooc.com/api/http/user



### GET和POST的对比

1. 语义

   - GET：获取数据

   - POST：创建数据



2. 发送数据

   **GET** 通过地址在请求头中携带数据

   - 能携带的数据量和地址的长度有关系，一般最多就几K



   **POST** 既可以通过地址在请求头中携带数据，也可以通过请求体携带数据

   - 能携带的数据量理论上是无限的

   - 携带少量数据，可以使用 GET 请求，大量的数据可以使用 POST 请求

   - send方法发送的数据，是通过请求体携带的，POST请求可以通过“xhr.send(`username=${encodeURIComponent('张三')} `);”的形式发送数据

     


3. 缓存

   GET 可以被缓存，POST 不会被缓存



4. 安全性

   ?username=alex

   GET 和 POST 都不安全

   发送密码或其他敏感信息时不要使用 GET，主要是避免直接被他人窥屏或通过历史记录找到你的密码



### HTTP状态码

1. HTTP 状态码是什么

   **定义服务器对请求的处理结果，是服务器返回的**



2. HTTP 状态码的语义

   

   100~199 消息：代表请求已被接受，需要继续处理
   - websocket (ws)



   200~299 成功
   - 200 (最常见)



   300~399 重定向
   - 301 Moved Permanently （重定向位置会被浏览器保存，除非缓存清空）
   - 302 Move Temporarily （不会保存到缓存，每次请求都要从服务器获取新地址）
   - 304 Not Modified （文件没有被修改，可以继续使用。）



   400~499 请求错误
   - 404 Not Found

     


   500~599 服务器错误
   - 500 Internal Server Error



------



## 本地存储

### Cookie

#### 基本认识

##### Cookie 是什么

- Cookie 全称 HTTP Cookie，简称 Cookie
- 是**浏览器**存储数据的一种方式
- 因为**存储在用户本地**，而不是存储在服务器上，是本地存储
-  一般会自动随着浏览器每次请求发送到服务器端



##### Cookie 有什么用

- 利用 Cookie 跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等



##### 在浏览器中操作 Cookie

- 不要在 Cookie 中保存密码等敏感信息



#### 基本用法

##### 写入 Cookie

```JavaScript
//在浏览器console控制台可以直接输入document.cookie查看Cookie

//在JS中添加Cookie
document.cookie = 'username=zs';

document.cookie = 'age=18';

//不能一起设置，只能一个一个设置
document.cookie = 'username=zs; age=18';
```



##### 读取 Cookie

```javascript
console.log(document.cookie);

// 读取的是一个由名值对构成的字符串，每个名值对之间由“; ”（一个分号和一个空格）隔开
//username=zs; age=18
```



#### Cookie属性

##### Cookie 的名称（Name）和值（Value）

- 最重要的两个属性，创建 Cookie 时必须填写，其它属性可以使用默认值

- Cookie 的名称或值如果包含非英文字母，则写入时需要使用 encodeURIComponent() 编码，读取时使用 decodeURIComponent() 解码:

```javascript
document.cookie = 'username=alex';

document.cookie = `username=${encodeURIComponent('张三')}`;

document.cookie = `${encodeURIComponent('用户名')}=${encodeURIComponent(
    '张三'
)}`;

// 一般名称使用英文字母，不要用中文，值可以用中文，但是要编码
```



##### 失效（到期）时间

- 对于失效的 Cookie，会被浏览器清除

- 如果没有设置失效（到期）时间，这样的 Cookie 称为会话 Cookie (Session)

- 它存在内存中，当会话结束，也就是浏览器关闭时，Cookie 消失

```javascript
 // document.cookie = 'username=alex';
```



- 想长时间存在，设置 Expires 或 Max-Age

```javascript
// expires 到期时间
// 值为 Date 类型

document.cookie = `username=alex; expires=${new Date(
    '2100-1-01 00:00:00'
)}`;



// max-age
// 值为数字，表示当前时间 + 多少秒后过期，单位是秒

document.cookie = 'username=alex; max-age=5';
document.cookie = `username=alex; max-age=${24 * 3600 * 30}`; //30天



// 如果 max-age 的值是 0 或负数，则 Cookie 会被删除

document.cookie = 'username=alex';
document.cookie = 'username=alex; max-age=0';
document.cookie = 'username=alex; max-age=-1';
```



##### Domain 域

- Domain 限定了访问 Cookie 的范围（不同域名）

- 使用 JS 只能读写当前域或父域的 Cookie，无法读写其他域的 Cookie

```javascript
document.cookie = 'username=alex; domain=www.imooc.com';

// www.imooc.com 可以访问 
// www.m.imooc.com 不能访问

// 父域：.imooc.com
//设置父域，可以让子域也访问到（以上两个例子都可以访问到）
```



##### Path 路径

- Path 限定了访问 Cookie 的范围（同一个域名下）

```javascript
// 使用 JS 只能读写当前路径和上级路径的 Cookie，无法读写下级路径的 Cookie

document.cookie = 'username=alex; path=/course/list';
document.cookie = 'username=alex; path=/1.Cookie/';


// 当 Name、Domain、Path 这 3 个字段都相同的时候，才是同一个 Cookie
```



##### HttpOnly

- 设置了 HttpOnly 属性的 Cookie 不能通过 JS 去访问



##### Secure 安全标志

- Secure 限定了只有在使用了 **https** 而不是 http 的情况下才可以发送给服务端

- Domain、Path、Secure 都要满足条件，还不能过期的 Cookie 才能随着请求发送到服务器端



#### Cookie封装

**cookie.js**

```javascript
// 写入 Cookie
const set = (name, value, { maxAge, domain, path, secure } = {}) => {
    //{}代表{maxAge}等的默认值，即空对象，避免undefined
    
  let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;

  if (typeof maxAge === 'number') {
    cookieText += `; max-age=${maxAge}`;
  }

  if (domain) {
    cookieText += `; domain=${domain}`;
  }

  if (path) {
    cookieText += `; path=${path}`;
  }

  if (secure) {
    cookieText += `; secure`;
  }

  document.cookie = cookieText;

  // document.cookie='username=alex; max-age=5; domain='
};

// 通过 name 获取 cookie 的值
const get = name => {
  name = `${encodeURIComponent(name)}`;

  const cookies = document.cookie.split('; ');

  for (const item of cookies) {
    const [cookieName, cookieValue] = item.split('=');

    if (cookieName === name) {
      return decodeURIComponent(cookieValue);
    }
  }

  return;
};

// 'username=alex; age=18; sex=male'
// ["username=alex", "age=18", "sex=male"]
// ["username","alex"]


// 根据 name、domain 和 path 删除 Cookie
const remove = (name, { domain, path } = {}) => {
  set(name, '', { domain, path, maxAge: -1 });
};

export { set, get, remove };

//使用例子：

// set('username', 'alex');
// set('username', 'zs');
// set('age', 18);
// set('用户名', '张三');
// set('sex', 'male', {
	//   maxAge: 30 * 24 * 3600
// });

// remove('username');
// remove('用户名');

// console.log(get('username'));
// console.log(get('age'));
// console.log(get('用户名'));
// console.log(get('sex'));
```



**index.html**

```html
<body>
    <button id="cn">中文</button>
    <button id="en">英文</button>
</body>
<script type="module">
	  import { set, get, remove } from './cookie.js';

      // 使用封装好的 Cookie 实现网站语言切换
      const cnBtn = document.getElementById('cn');
      const enBtn = document.getElementById('en');

      cnBtn.addEventListener(
        'click',
        () => {
          set('language', 'cn', {
            maxAge: 30 * 24 * 3600
          });
          window.location = './2-6.Cookie 的封装.html'; //强制刷新，cookie会上传到服务器端
        },
        false
      );
      enBtn.addEventListener(
        'click',
        () => {
          set('language', 'en', {
            maxAge: 30 * 24 * 3600
          });
          window.location = './2-6.Cookie 的封装.html';
        },
        false
      );
</script>
```



#### Cookie 注意事项

##### 前后端都可以创建 Cookie



##### Cookie 有数量限制

- 每个域名下的 Cookie 数量有限

- 当超过单个域名限制之后，再设置 Cookie，浏览器就会清除以前设置的 Cookie



##### Cookie 有大小限制

- 每个 Cookie 的存储容量很小，最多只有 4KB 左右



### localStorage



```html
<body>
    <form id="login" action="https://www.imooc.com" method="post">
      <input type="text" name="username" />
      <input type="password" name="password" />
      <input type="submit" id="btn" value="登录" />
    </form>
</body>
<script>
 ...
</script>
```



##### localStorage 是什么

- localStorage 也是一种浏览器存储数据的方式（本地存储），它只是存储在本地，不会发送到服务器端

- 单个域名下的 localStorage 总大小有限制（一般2MB-5MB）



##### 在浏览器中操作 localStorage

Application -> Storage -> Local Storage

按域名存储，分Key和Value



##### localStorage 的基本用法

```javascript
console.log(localStorage);

// setItem()

localStorage.setItem('username', 'alex');
localStorage.setItem('username', 'zs');
localStorage.setItem('age', 18);
localStorage.setItem('sex', 'male');


// length

console.log(localStorage.length);


// getItem()

console.log(localStorage.getItem('username'));
console.log(localStorage.getItem('age'));



// 获取不存在的返回 null

console.log(localStorage.getItem('name'));


// removeItem()

localStorage.removeItem('username');
localStorage.removeItem('age');

// 删除不存在的 key，不报错
localStorage.removeItem('name');


// clear()

localStorage.clear();

console.log(localStorage); // Storage {length: 0}
```



##### 使用 localStorage 实现自动填充

```javascript
const loginForm = document.getElementById('login');
const btn = document.getElementById('btn');

const username = localStorage.getItem('username');

if (username) {
    loginForm.username.value = username;
}

btn.addEventListener(
    'click',
    e => {
        e.preventDefault();//阻止点击按钮后的默认提交
        // 数据验证
        // console.log(loginForm.username.value);
        
        localStorage.setItem('username', loginForm.username.value);
        loginForm.submit();
    },false
);
```



#### localStorage注意事项

##### localStorage 的存储期限

- localStorage 是持久化的本地存储，除非手动清除（比如通过 js 删除，或者清除浏览器缓存），否则数据是永远不会过期的

```javascript
// sessionStorage
// 当会话结束（比如关闭浏览器）的时候，sessionStorage 中的数据会被清空

sessionStorage.setItem('username', 'alex');
sessionStorage.getItem('username');
sessionStorage.removeItem('username');
sessionStorage.clear();
```



##### localStorage 键和值的类型

- localStorage 存储的键和值只能是字符串类型

- 不是字符串类型，也会先转化成字符串类型再存进去

```javascript
localStorage.setItem({}, 18);

console.log(
    typeof localStorage.getItem('[object Object]'),
    localStorage.getItem('[object Object]')
); //string 18

console.log({}.toString()); //[boject object]

//以下这种类型，此处暂且不讲解
localStorage.setItem('students', [{},{}]);
```



##### 不同域名下能否共用 localStorage

- 不同的域名是不能共用 localStorage 的



##### localStorage 的兼容性

- IE7及以下版本不支持 localStorage，IE8 开始支持

www.caniuse.com 

此网站可以查找兼容性问题
